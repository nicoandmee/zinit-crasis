# -*- mode: shell-script -*-
# Started from Zle or from command line
#
# Copyright (c) 2017 Sebastian Gniazdowski

-zui_std_cleanup deserialize:"zplugin-crasis"
-zui_std_init app:"zplugin-crasis" app_name:"Zplugin-Crasis"
emulate -LR zsh -o extendedglob -o typesetsilent -o warncreateglobal
-zui_std_init2

-zui_std_store_default_app_config b:text_mode off
-zui_std_store_default_app_config b:text_select off
-zui_std_store_default_app_config b:border 1
-zui_std_store_default_app_config b:top_anchors 0  # no top-anchors

#
# CONSTANTS
#

local -A TOKEN_TYPES

TOKEN_TYPES=(

  # Precommand

  'builtin'     1
  'command'     1
  'exec'        1
  'nocorrect'   1
  'noglob'      1
  'pkexec'      1

  # Control flow
  # Tokens that at "command position" are followed by a command

  $'\x7b'   2 # {
  $'\x28'   2 # (
  '()'      2
  'while'   2
  'until'   2
  'if'      2
  'then'    2
  'elif'    2
  'else'    2
  'do'      2
  'time'    2
  'coproc'  2
  '!'       2

  # Command separators

  '|'   3
  '||'  3
  ';'   3
  '&'   3
  '&&'  3
  '|&'  3
  '&!'  3
  '&|'  3
)
#
# PARAMETERS
#

# Document to process
local zshrc_path="${ZDOTDIR:-$HOME}/.zshrc" zshrc

# The bits returned by -zplg-process-buffer
local token prev_token spaces prev_spaces next_token next_spaces

# Command detection
integer at_command=1 in_zplugin=0

# Functions
local fun_name
integer next_fun=0 cur_fun=0 prev_fun=0

# Depths in functions, i.e. -1 not in function, 0 in one function, etc.
integer depth=0 prev_depth=0 fun_depth=-1 anon_depth=-1 descentff=0 descentfa=0

# Nested functions tracking
integer nested_fun=0 next_nested_fun=0 prev_nested_fun=0
local -a fun_stack_depths

# Text and commands data
integer was_zplugin=0 pre_block_end=0 post_block_begin=0
local -A cmd3
local -a cmdlist
integer coidx=1

# Common
local -a mbegin mend match
local MATCH; integer MBEGIN MEND
local internal # to mark inline action as no-ZUI-restart

# Debug array, for debug view
local -a ZCR_DEBUG_MSGS

#
# Load zshrc
#

[[ ! -e "$zshrc_path" ]] && { print "No such file \`$zshrc_path'${ZDOTDIR:+ (using \$ZDOTDIR)}"; return 1; }
[[ ! -f "$zshrc_path" ]] && { print "\`$zshrc_path' isn't a plain, regular file${ZDOTDIR:+ (using \$ZDOTDIR)}"; return 1; }
[[ ! -r "$zshrc_path" ]] && { print "No read permissions to \`$zshrc_path'${ZDOTDIR:+ (using \$ZDOTDIR)}"; return 1; }
[[ ! -w "$zshrc_path" ]] && { print "No write permissions to \`$zshrc_path'${ZDOTDIR:+ (using \$ZDOTDIR)}"; return 1; }
[[ ! -s "$zshrc_path" ]] && { print "File \`$zshrc_path' is empty, aborting"; return 1; }

local zshrc="$(<$zshrc_path)"

# Runs -zcrasis-process-buffer() on $zshrc (containing
# the loaded zshrc)
-zcrasis-tokenize-zsh-rc() {
    -zcrasis-process-buffer "$zshrc" 1
}

# Parses tokens of the loaded zshrc and detects:
# - functions
# - block preceding zplugin commands
# - block with those commands
# - block following them
-zcrasis-process-zsh-rc() {
    integer i j size="${#ZCR_PB_WORDS}"

    for (( i=1; i<=size; ++ i )); do
        token="${ZCR_PB_WORDS[i]}"
        spaces="${ZCR_PB_SPACES[i]}"
        next_token="${ZCR_PB_WORDS[i+1]}"
        next_spaces="${ZCR_PB_SPACES[i+1]}"

        cur_fun=0 prev_fun=0 descentff=0 descentfa=0
        nested_fun=0 prev_nested_fun=0

        (( next_fun )) && { next_fun=0 cur_fun=1 prev_fun=0 anon_depth=-1; }
        (( next_nested_fun )) && { next_nested_fun=0 nested_fun=1 prev_nested_fun=0; }

        # Explicit future-function
        if [[ "$token" = "function" && ( "$fun_depth" -lt 0 ) && ( $anon_depth -lt 0 ) ]]; then
            next_fun=1 cur_fun=0 prev_fun=0 anon_depth=-1
        # Detect top-level prev-function differentiating from anonymous function
        elif [[ "$token" = "()" && ( "$fun_depth" -lt 0 ) && ( $anon_depth -lt 0 ) ]]; then
            if [[ "$spaces" = *$'\n'* || -z "$prev_token" || "${TOKEN_TYPES[$prev_token]}" = [123] ]]; then
                next_fun=0 cur_fun=0 prev_fun=0 anon_depth=$depth
            else
                next_fun=0 cur_fun=0 prev_fun=1 anon_depth=-1
            fi
        # Must be a nested future-function
        elif [[ "$token" = "function" ]]; then
            next_nested_fun=1 nested_fun=0 prev_nested_fun=0
        # Is it a nested prev-function?
        elif [[ "$token" = "()" && "$nested_fun" -eq 0 && "$depth" -gt "$fun_stack_depths[-1]" ]]; then
            if [[ "$spaces" != *$'\n'* && -n "$prev_token" && "${TOKEN_TYPES[$prev_token]}" != [123] ]]; then
                next_nested_fun=0 nested_fun=0 prev_nested_fun=1
            fi
        elif [[ "$token" = "{" ]]; then
            (( ++ depth ))
        elif [[ "$token" = "}" ]]; then
            (( -- depth ))
        fi

        # Check if any final function-flag is raised
        if (( cur_fun )); then
            fun_name="$token"
            fun_depth="$depth"
            fun_stack_depths+=( "$depth" )
        elif (( prev_fun )); then
            fun_name="$prev_token"
            fun_depth="$depth"
            fun_stack_depths+=( "$depth" )
        fi

        # Track nested functions
        if (( nested_fun + prev_nested_fun )); then
            fun_stack_depths+=( "$depth" )
        fi

        # Ascent to function - skip '{'
        if (( fun_depth >= 0 && depth == (fun_depth + 1) )) && [[ "$token" = "{" ]]; then
            :
        # In function
        elif (( fun_depth >= 0 && depth > fun_depth )); then
            if [[ "$token" != [[:blank:]]#\#* ]]; then
                : # do something with a non-comment function token
            fi
            # Handle descent from nested function
            if (( ${#fun_stack_depths} > 0 && depth == fun_stack_depths[-1] && prev_depth == fun_stack_depths[-1] + 1 )); then
                fun_stack_depths[-1]=()
            fi
        # In anonymous-function
        elif (( anon_depth >= 0 && depth > anon_depth )); then
            if (( ${#fun_stack_depths} > 0 && depth == fun_stack_depths[-1] && prev_depth == fun_stack_depths[-1] + 1 )); then
                fun_stack_depths[-1]=()
            fi
        # Descent from function - skip '}'
        elif (( fun_depth >= 0 && depth == fun_depth && prev_depth == fun_depth + 1 )); then
            descentff=1
        # Descent from anon
        elif (( anon_depth >= 0 && depth == anon_depth && prev_depth == anon_depth + 1 )); then
            descentfa=1
        fi

        # Anon function in top-level
        if (( anon_depth >= 0 && fun_depth < 0 )); then
            [[ "$token" != [[:blank:]]#\#* ]] && : # do something with non-comment anon-function token
        fi

        # Check for introduction of Zplugin call
        if [[ "$spaces" = *$'\n'* || -z "$prev_token" || "${TOKEN_TYPES[$prev_token]}" = [123] ]]; then
            at_command=1
            (( in_zplugin )) && post_block_begin=2*i-1
            [[ "$token" != [[:blank:]]#\#* ]] && in_zplugin=0 || { (( in_zplugin )) && in_zplugin=1; }
        fi

        # Command token
        if (( at_command )); then
            at_command=0
            # Zplugin call not in function
            if [[ "$cur_fun" -eq 0 && "$next_token" != "()" && "$fun_stack_depths[-1]" -le "0" ]]; then
                if [[ "$token" = (zplugin|zplg) || ( "$token" = ":" && "$next_token" = (zplugin|zplg) ) ]]; then
                    in_zplugin=1
                    (( was_zplugin == 0 )) && {
                        for (( j=i-1; j >= 1; j -- )); do
                            [[ "${ZCR_PB_WORDS[j]}" != [[:blank:]]#\#* || "${ZCR_PB_SPACES[j+1]}" = *$'\n'*$'\n'* ]] && { pre_block_end=2*j; break; }
                        done
                    }
                    was_zplugin=1

                    # Revive at_command mode if disabled zplugin command
                    [[ "$token" = ":" ]] && at_command=1
                fi
            fi
        fi

        # Late disable of anonymous function
        if (( descentfa )); then
            anon_depth=-1
        # Late disable of normal function
        elif (( descentff )); then
            fun_name=""
            fun_depth=-1
            fun_stack_depths[-1]=()
        # No-function text gathering
        elif (( next_fun == 0 && cur_fun == 0 && prev_fun == 0 && anon_depth < 0 && fun_depth < 0 )); then
            if [[ "$next_token" != "()" || "$next_spaces" = *$'\n'* || "${TOKEN_TYPES[$token]}" = 3 ]]; then
                [[ "$token" != [[:blank:]]#\#* ]] && : # do something with script-body token
            fi
        fi

        # History of state
        prev_depth="$depth"
        prev_token="$token"
        prev_spaces="$spaces"
    done

    (( pre_block_end == 0 )) && pre_block_end=2*(i-1)
    (( post_block_begin == 0 )) && post_block_begin=2*i-1 || {
        # Detect not related trailing comments
        for (( j=(post_block_begin+1)/2-1; j >= 1; j -- )); do
            [[ "${ZCR_PB_WORDS[j]}" = [[:blank:]]#\#* && "${ZCR_PB_WORDS[j]}" != [[:blank:]]#\#[[:blank:]]#zplugin* ]] && {
                post_block_begin=2*j-1
            } || break
        done
    }
}

# Processes block with zplugin commands established in
# -zcrasis-process-zsh-rc() and generates $commands
# array which holds serialized hashes of every zplugin
# invocation, mixed-in additional commands, comments.
-zcrasis-process-zplugin-commands() {
    cmd3=()
    # From start to end of zplugin block
    for (( i=(pre_block_end/2)+1; i<=(post_block_begin+1)/2-1; ++ i )); do
        token="${ZCR_PB_WORDS[i]}"
        spaces="${ZCR_PB_SPACES[i]}"
        next_token="${ZCR_PB_WORDS[i+1]}"
        next_spaces="${ZCR_PB_SPACES[i+1]}"

        # New command?
        if [[ "$spaces" = *$'\n'* || -z "$prev_token" || "${TOKEN_TYPES[$prev_token]}" = [123] ]]; then
            in_zplugin=1

            if [[ "${cmd3[c]}" = "zplugin" && "${cmd3[sub]}" = "ice" ]]; then
                [[ -n "${cmdlist[coidx]}" ]] && cmdlist[coidx]+=$'\n'
                cmdlist[coidx+1]="${(j: :)${(qkv)cmd3[@]}}"
            elif [[ "${cmd3[c]}" = "zplugin" && "${cmd3[sub]}" != "ice" ]]; then
                [[ -n "${cmdlist[coidx]}" ]] && cmdlist[coidx]+=$'\n'
                cmdlist[coidx+2]="${(j: :)${(qkv)cmd3[@]}}"
                coidx+=3
            else
                # Don't increase coidx untill we get some command.
                # This causes preceding comments to accumulate.
                if [[ -n "${cmd3[c]}" ]]; then
                    # Custom command
                    [[ -n "${cmdlist[coidx]}" ]] && cmdlist[coidx]+=$'\n'
                    cmdlist[coidx+2]="${(j: :)${(qkv)cmd3[@]}}"
                    coidx+=3
                fi
            fi

            cmd3=()
        fi

        # Command token
        if [[ "$token" = [[:blank:]]#\#* ]]; then
            if (( in_zplugin == 1 )); then
                cmdlist[coidx]+="$spaces$token"
            else
                cmd3[comment]="$spaces$token"
            fi
        elif (( in_zplugin == 1 )); then
            [[ "$token" = (zplugin|zplg) ]] && cmd3[c]="zplugin" || cmd3[c]="$token"
            # Postpone current state to next token
            [[ "$token" = ":" ]] && { cmd3[disabled]=1; (( in_zplugin -- )); }
        elif (( in_zplugin == 2 )); then
            if [[ "${cmd3[c]}" = "zplugin" ]]; then
                [[ "$token" = (ice|load|light|snippet|cdclear|cdreplay) ]] && cmd3[sub]="$token" || { cmd3[sub]="unkn"; cmd3[unkn]="$token"; }
            else
                cmd3[arg_1]="$token"
            fi
        else
            if [[ "${cmd3[sub]}" = "ice" ]]; then
                [[ "$token" = (#b)(from|proto|report|depth|blockf|atload|atpull|atclone|if)(*) ]] && cmd3[${match[1]}]="${match[2]}"
            elif [[ "${cmd3[sub]}" = (load|light) ]]; then
                if (( in_zplugin == 4 )); then
                    cmd3[url]+="/$token"
                else
                    cmd3[url]="$token"
                fi
            elif [[ "${cmd3[sub]}" = "snippet" ]]; then
                [[ "$token" = "-f" ]] && cmd3[-f]="1" || {
                    [[ "$token" = "--command" ]] && cmd3[--command]="1" || {
                        cmd3[url]="$token"
                    }
                }
            elif [[ "${cmd3[sub]}" = "cdclear" ]]; then
                [[ "$token" = "-q" ]] && cmd3[-q]="1"
            elif [[ "${cmd3[sub]}" = "cdreplay" ]]; then
                :
            elif [[ "${cmd3[sub]}" = "unkn" ]]; then
                # Argument following "zplugin <unknown> ..."
                cmd3[arg_$(( in_zplugin - 2 ))]="$token"
            else
                # Argument following "<unknown> <arg_1> ..."
                cmd3[arg_$(( in_zplugin - 1 ))]="$token"
            fi
        fi

        # Advance deeper into "zplugin ..." if it wasn't comment
        #[[ "$token" != [[:blank:]]#\#* ]] && in_zplugin+=1
        in_zplugin+=1
    done

    if [[ -n "${cmd3[c]}" ]];then
        if [[ "${cmd3[c]}" = "zplugin" && "${cmd3[sub]}" = "ice" ]]; then
            cmdlist[coidx+1]="${(j: :)${(qkv)cmd3[@]}}"
        elif [[ "${cmd3[c]}" = "zplugin" && "${cmd3[sub]}" != "ice" ]]; then
            cmdlist[coidx+2]="${(j: :)${(qkv)cmd3[@]}}"
        fi
    fi
}

# Moves given instance ($ice) up, i.e. swaps
# current and previous instance
-zcrasis_move_up() {
    local mod="$1" ice="$2" tmp

    local -a cmd1 cmd2

    cmd1=( "${(@)cmdlist[(ice-1-1)*3+1,(ice-1)*3+1]}" )
    cmd2=( "${(@)cmdlist[(ice-1)*3+1,ice*3]}" )

    cmdlist[(ice-1-1)*3+1,(ice-1)*3+1]=( "${cmd2[@]}" )
    cmdlist[(ice-1)*3+1,ice*3]=( "${cmd1[@]}" )

    tmp="${ZUI[toggle_dis_${mod}_${ice}]}"
    ZUI[toggle_dis_${mod}_${ice}]="${ZUI[toggle_dis_${mod}_$(( ice-1 ))]}"
    ZUI[toggle_dis_${mod}_$(( ice-1 ))]="$tmp"

    tmp="${ZUI[toggle_command_${mod}_${ice}]}"
    ZUI[toggle_command_${mod}_${ice}]="${ZUI[toggle_command_${mod}_$(( ice-1 ))]}"
    ZUI[toggle_command_${mod}_$(( ice-1 ))]="$tmp"

    tmp="${ZUI[toggle_force_${mod}_${ice}]}"
    ZUI[toggle_force_${mod}_${ice}]="${ZUI[toggle_force_${mod}_$(( ice-1 ))]}"
    ZUI[toggle_force_${mod}_$(( ice-1 ))]="$tmp"

    tmp="${ZUI[toggle_mode_${mod}_${ice}]}"
    ZUI[toggle_mode_${mod}_${ice}]="${ZUI[toggle_mode_${mod}_$(( ice-1 ))]}"
    ZUI[toggle_mode_${mod}_$(( ice-1 ))]="$tmp"
}

# Moves given instance ($ice) down, i.e. swaps
# current and next instance
-zcrasis_move_down() {
    local mod="$1" ice="$2" tmp

    local -a cmd1 cmd2

    cmd1=( "${(@)cmdlist[(ice-1)*3+1,ice*3]}" )
    cmd2=( "${(@)cmdlist[(ice-1+1)*3+1,(ice+1)*3+1]}" )

    cmdlist[(ice-1)*3+1,ice*3]=( "${cmd2[@]}" )
    cmdlist[(ice-1+1)*3+1,(ice+1)*3+1]=( "${cmd1[@]}" )

    tmp="${ZUI[toggle_dis_${mod}_${ice}]}"
    ZUI[toggle_dis_${mod}_${ice}]="${ZUI[toggle_dis_${mod}_$(( ice+1 ))]}"
    ZUI[toggle_dis_${mod}_$(( ice+1 ))]="$tmp"

    tmp="${ZUI[toggle_command_${mod}_${ice}]}"
    ZUI[toggle_command_${mod}_${ice}]="${ZUI[toggle_command_${mod}_$(( ice+1 ))]}"
    ZUI[toggle_command_${mod}_$(( ice+1 ))]="$tmp"

    tmp="${ZUI[toggle_force_${mod}_${ice}]}"
    ZUI[toggle_force_${mod}_${ice}]="${ZUI[toggle_force_${mod}_$(( ice+1 ))]}"
    ZUI[toggle_force_${mod}_$(( ice+1 ))]="$tmp"

    tmp="${ZUI[toggle_mode_${mod}_${ice}]}"
    ZUI[toggle_mode_${mod}_${ice}]="${ZUI[toggle_mode_${mod}_$(( ice+1 ))]}"
    ZUI[toggle_mode_${mod}_$(( ice+1 ))]="$tmp"
}

# Enters preview view
-zcrasis_preview() {
    -zui_std_set_mod_factor 4 0
    ZUI[in_debug]=0
    if [[ "${ZUI[in_preview]}" != 1 ]]; then
        -zui_std_set_mod_factor 2 0
        -zui_std_set_mod_factor 3 1
        ZUI[in_preview]=1
    else
        -zui_std_set_mod_factor 2 $(( ${#cmdlist} / 3 ))
        -zui_std_set_mod_factor 3 0
        ZUI[in_preview]=0
    fi

    # To update "[Preview]" button
    -zui_std_fly_mod_regen 1 1 ""

    # Regenerate preview module
    reply=( ",mod3_ice1," "" )
}

# Enters debug view
-zcrasis_debug() {
    -zui_std_set_mod_factor 3 0
    ZUI[in_preview]=0

    if [[ "${ZUI[in_debug]}" != 1 ]]; then
        -zui_std_set_mod_factor 2 0
        -zui_std_set_mod_factor 4 1
        ZUI[in_debug]=1
    else
        -zui_std_set_mod_factor 2 $(( ${#cmdlist} / 3 ))
        -zui_std_set_mod_factor 4 0
        ZUI[in_debug]=0
    fi

    # To update "[Debug]" button
    -zui_std_fly_mod_regen 1 1 ""

    # Regenerate debug module
    reply=( ",mod4_ice1," "" )
}

# Appends debug message to log of the debug view
-zcrasis_dbg_msg() {
    ZCR_DEBUG_MSGS+=( "$*" )
}

# Removes given entry from $cmdlist and orders
# full regeneration of commands-section
-zcrasis_delete() {
    local id="$1" mod="$2" ice="$3"
    cmdlist[(ice-1)*3+1,ice*3]=()

    local rtext=","
    integer i size=$(( ${#cmdlist} / 3 ))

    -zui_std_set_mod_factor 2 "$size"

    for (( i=1; i<=size; ++ i )); do
        rtext+="mod${mod}_ice${i},"
    done

    reply=( "$rtext" "" )
}

# Enables ability to delete entries
-zcrasis_delete_mode() {
    if [[ -n "${ZUI[zc_delete_mode]}" ]]; then
        (( ZUI[zc_delete_mode] = 1 - ZUI[zc_delete_mode] ))
    else
        ZUI[zc_delete_mode]=1
    fi

    local rtext=",mod1_ice1,"
    integer i size=$(( ${#cmdlist} / 3 ))

    for (( i=1; i<=size; ++ i )); do
        rtext+="mod2_ice${i},"
    done

    reply=( "$rtext" "" )
}

-zcrasis_compose() {
    local with_comments="$1" whole="$2"
    local buf="" tmp comment
    integer i size=$(( ${#commands} / 3 ))
    local -a cmd
    local -A ice_cmd main_cmd

    [[ "$whole" = "1" ]] && buf="${(j::)ZCR_PB_ALL[1,pre_block_end]}"$'\n'

    for (( i=1; i<=size; ++ i )); do
        cmd=( "${(@)cmdlist[(i-1)*3+1,i*3]}" )
        comment="${cmd[1]}"
        ice_cmd=() main_cmd=()
        [[ -n "${cmd[2]}" ]] && ice_cmd=( "${(z@)cmd[2]}" )
        [[ -n "${cmd[3]}" ]] && main_cmd=( "${(z@)cmd[3]}" )

        ice_cmd=( "${(Qkv)ice_cmd[@]}" )
        main_cmd=( "${(Qkv)main_cmd[@]}" )

        # Comment
        [[ "$with_comments" = "1" ]] && buf+="$comment"

        # ICE
        if [[ "${#ice_cmd}" -ge 1 ]]; then
            (( ice_cmd[disabled] || main_cmd[disabled] )) && buf+=": "
            buf+="zplugin ice"
            for tmp in "${(ok@)ice_cmd}"; do
                case "$tmp" in
                    (from|proto|report|depth|atload|atpull|atclone|if)
                        buf+=" $tmp${ice_cmd[$tmp]}"
                        ;;
                    (blockf)
                        buf+=" $tmp"
                        ;;
                esac
            done
            buf+=$'\n'
        fi

        # COMMAND
        if [[ "${#main_cmd}" -ge 1 ]]; then
            if [[ "${main_cmd[c]}" = (zplugin|zplg) ]]; then
                (( ice_cmd[disabled] || main_cmd[disabled] )) && buf+=": "
                if [[ "${main_cmd[sub]}" = (light|load|snippet|cdreplay|cdclear) ]]; then
                    buf+="zplugin ${main_cmd[sub]}"
                    [[ -n "${main_cmd[--command]}" ]] && buf+=" --command"
                    [[ -n "${main_cmd[-f]}" ]] && buf+=" -f"
                    [[ -n "${main_cmd[-q]}" ]] && buf+=" -q"
                    [[ -n "${main_cmd[url]}" ]] && buf+=" ${main_cmd[url]}"
                else
                    # Unknown subcommand
                    local -a keys
                    local key text="${main_cmd[c]}"
                    [[ -n "${main_cmd[unkn]}" ]] && text+=" ${main_cmd[unkn]}"
                    keys=( "${(kon)main_cmd[@]}" )
                    for key in "${keys[@]}"; do
                        [[ "$key" != arg_* ]] && continue
                        text+=" ${main_cmd[$key]}"
                    done

                    buf+="$text"
                fi
            else
                local -a keys
                local key text="${main_cmd[c]}"
                keys=( "${(kon)main_cmd[@]}" )
                for key in "${keys[@]}"; do
                    [[ "$key" != arg_* ]] && continue
                    text+=" ${main_cmd[$key]}"
                done
                buf+="$text"
            fi
            buf+=$'\n'
        fi
    done

    [[ "$whole" = "1" ]] && buf+="${(j::)ZCR_PB_ALL[post_block_begin,-1]}"

    reply=( "${(@f)buf}" )
}

-zcrasis_save() {
    -zcrasis_compose 1 1
    print -rl -- "${reply[@]}" >| ~/.myzshrc
    reply=()

    -zui_std_stalog "Saved to:" "\`$zshrc_path'"
}

-zcrasis_generator_0() {
    local mod="$1" ice="$2"
    local pv_col dg_col dl_col

    reply=()

    -zui_util_map_bools '[[ ${ZUI[in_preview]} = 1 ]]' pv_col "${ZUI[BG_BLUE]}" "${ZUI[GREEN]}"
    -zui_util_map_bools '[[ ${ZUI[in_debug]} = 1 ]]' dg_col "${ZUI[BG_BLUE]}" "${ZUI[GREEN]}"
    -zui_util_map_bools '[[ "${ZUI[zc_delete_mode]}" = "1" ]]' dl_col "${ZUI[BG_BLUE]}" "${ZUI[RED]}"

    -zui_std_rc_button "reload" "${ZUI[GREEN]}Reload${ZUI[FMT_END]}" -zcrasis_reload
    -zui_std_rc_button "save" "${ZUI[RED]}Save${ZUI[FMT_END]}" '-zcrasis_save; internal=1'
    -zui_std_rc_button "preview" "${pv_col}Preview${ZUI[FMT_END]}" -zcrasis_preview
    -zui_std_rc_button "debug" "${dg_col}Debug${ZUI[FMT_END]}" -zcrasis_debug
    -zui_std_rc_button "delete_mode" "${dl_col}Delete Mode${ZUI[FMT_END]}" -zcrasis_delete_mode

    reply=(
        "${reply[1]} ${reply[2]} ${reply[3]} ${reply[4]}"
        "${reply[5]}"
    )

    # Non-selectable lines   Hops to jump with [ and ]   Local anchors
    reply2=( )               reply3=( 1 )                reply4=( )
}

# Generator for module 1
-zcrasis_generator_A() {
    local mod="$1" ice="$2" comment
    local -a cmd output
    local -A ice_cmd main_cmd
    local var_name1 var_name2
    local num dis_col mode_col command_col force_col disabled_text

    cmd=( "${(@)cmdlist[(ice-1)*3+1,ice*3]}" )
    comment="${cmd[1]}"
    [[ -n "${cmd[2]}" ]] && ice_cmd=( "${(z@)cmd[2]}" )
    [[ -n "${cmd[3]}" ]] && main_cmd=( "${(z@)cmd[3]}" )

    ice_cmd=( "${(Qkv)ice_cmd[@]}" )
    main_cmd=( "${(Qkv)main_cmd[@]}" )

    output=()

    # Command number
    num="${(l:2::0:)ice}."

    # "Up", "Down"
    var_name1="my_mod${mod}_ice$(( ice-1 ))_size"
    var_name2="my_mod${mod}_ice$(( ice+1 ))_size"

    if [[ "$ice" -gt 1 ]]; then
        -zui_std_anchor "move_up_${mod}_${ice}" "1-1-${var_name1}" "" ",mod${mod}_ice${ice},mod${mod}_ice$(( ice - 1 ))," "" "${ZUI[YELLOW]}[Up]${ZUI[FMT_END]}" "-zcrasis_move_up $mod $ice" output
    else
        output+=( "[Up]" )
    fi

    if [[ "$ice" -lt $(( ${#cmdlist} / 3 )) ]]; then
        -zui_std_anchor "move_down_${mod}_${ice}" "1+1+${var_name2}" "" ",mod${mod}_ice${ice},mod${mod}_ice$(( ice + 1 ))," "" "${ZUI[YELLOW]}[Down]${ZUI[FMT_END]}" "-zcrasis_move_down $mod $ice" output
    else
        output+=( "[Down]" )
    fi

    # "DISABLED" or "Enabled"
    [[ -z "${ZUI[toggle_dis_${mod}_${ice}]}" ]] && ZUI[toggle_dis_${mod}_${ice}]="${main_cmd[disabled]:-0}" || main_cmd[disabled]=${ZUI[toggle_dis_${mod}_${ice}]}
    -zui_util_map_bools "[[ \"${ZUI[toggle_dis_${mod}_${ice}]}\" = 1 ]]" "dis_col" "${ZUI[RED]}" "${ZUI[GREEN]}"
    -zui_util_map_bools "[[ \"${ZUI[toggle_dis_${mod}_${ice}]}\" = 1 ]]" "disabled_text" "DISABLED" "Enabled"

    -zui_std_rc_button "toggle_dis_${mod}_${ice}" "${dis_col}${disabled_text}${ZUI[FMT_END]}" '(( ZUI[toggle_dis_'"${mod}_${ice}"']=1-${ZUI[toggle_dis_'"${mod}_${ice}"']} )); -zui_std_fly_mod_regen '"$mod $ice"'; internal=1' output

    # Delete
    -zui_std_rc_button_ext "delete_${mod}_${ice}" "$mod" "$ice" "" "" "${ZUI[RED]}Delete${ZUI[FMT_END]}" -zcrasis_delete output
    if (( ZUI[zc_delete_mode] )); then
        output[4]+=" "
    else
        output[4]=""
    fi

    reply=()
    if [[ "${main_cmd[sub]}" = "snippet" ]]; then
        #
        # command on/off
        #

        [[ -z "${ZUI[toggle_command_${mod}_${ice}]}" ]] && ZUI[toggle_command_${mod}_${ice}]="${main_cmd[--command]:-0}" || main_cmd[--command]=${ZUI[toggle_command_${mod}_${ice}]}
        -zui_util_map_bools "[[ \"${ZUI[toggle_command_${mod}_${ice}]}\" = 1 ]]" "command_col" "${ZUI[BG_BLUE]}" "${ZUI[GREEN]}"
        local command_text="${command_col}as-command${ZUI[FMT_END]}"
        -zui_std_rc_button "toggle_command_${mod}_${ice}" "$command_text" '(( ZUI[toggle_command_'"${mod}_${ice}"']=1-${ZUI[toggle_command_'"${mod}_${ice}"']} )); -zui_std_fly_mod_regen '"$mod $ice"'; internal=1' output

        #
        # force on/off
        #

        [[ -z "${ZUI[toggle_force_${mod}_${ice}]}" ]] && ZUI[toggle_force_${mod}_${ice}]="${main_cmd[-f]:-0}" || main_cmd[-f]=${ZUI[toggle_force_${mod}_${ice}]}
        -zui_util_map_bools "[[ \"${ZUI[toggle_force_${mod}_${ice}]}\" = 1 ]]" "force_col" "${ZUI[BG_BLUE]}" "${ZUI[GREEN]}"
        local force_text="${force_col}force${ZUI[FMT_END]}"
        -zui_std_rc_button "toggle_force_${mod}_${ice}" "$force_text" '(( ZUI[toggle_force_'"${mod}_${ice}"']=1-${ZUI[toggle_force_'"${mod}_${ice}"']} )); -zui_std_fly_mod_regen '"$mod $ice"'; internal=1' output

        #
        # Document
        #

        reply+=( "$num ${output[1]} ${output[2]} S ${ZUI[MAGENTA]}${main_cmd[url]}${ZUI[FMT_END]}" )
        reply+=( "${output[3]} ${output[4]}${output[5]} ${output[6]}" )
    elif [[ "${main_cmd[sub]}" = (light|load) ]]; then
        #
        # Mode: light or normal ("load")
        #

        [[ -z "${ZUI[toggle_mode_${mod}_${ice}]}" ]] && ZUI[toggle_mode_${mod}_${ice}]="${main_cmd[sub]}" || main_cmd[sub]=${ZUI[toggle_mode_${mod}_${ice}]}
        -zui_util_map_bools "[[ \"${ZUI[toggle_mode_${mod}_${ice}]}\" = light ]]" "mode_col" "${ZUI[YELLOW]}" "${ZUI[GREEN]}"
        local mode_text="Mode: ${mode_col}${main_cmd[sub]}${ZUI[FMT_END]}"
        -zui_std_rc_button "toggle_mode_${mod}_${ice}" "$mode_text" '[[ ${ZUI[toggle_mode_'"${mod}_${ice}"']} = light ]] && ZUI[toggle_mode_'"${mod}_${ice}"']=load || ZUI[toggle_mode_'"${mod}_${ice}"']=light; -zui_std_fly_mod_regen '"$mod $ice"'; internal=1' output

        #
        # Document
        #

        reply+=( "$num ${output[1]} ${output[2]} P ${ZUI[CYAN]}${main_cmd[url]}${ZUI[FMT_END]}" )
        reply+=( "${output[3]} ${output[4]}${output[5]}" )
    elif [[ "${main_cmd[sub]}" = "cdreplay" ]]; then
        reply+=( "$num ${output[1]} ${output[2]} cdreplay" )
        reply+=( "${output[3]}${output[4]:+ }${output[4]% }" )
    elif [[ "${main_cmd[sub]}" = "cdclear" ]]; then
        reply+=( "$num ${output[1]} ${output[2]} cdclear" )
        reply+=( "${output[3]}${output[4]:+ }${output[4]% }" )
    else
        # Custom command
        local -a keys
        local key text="${main_cmd[c]}"
        [[ -n "${main_cmd[unkn]}" ]] && text+=" ${main_cmd[unkn]}"
        keys=( "${(kon)main_cmd[@]}" )
        for key in "${keys[@]}"; do
            [[ "$key" != arg_* ]] && continue
            text+=" ${main_cmd[$key]}"
        done
        [[ -n "${main_cmd[unkn]}" ]] && text+=" (${ZUI[RED]}unknown Zplugin subcommand${ZUI[FMT_END]})"
        reply+=( "$num ${output[1]} ${output[2]} $text" )
        reply+=( "${output[3]}${output[4]:+ }${output[4]% }" )
    fi

    # Instead of debugging ZUI, I've added '-1' here
    var_name1="my_mod${mod}_ice${ice}_size"
    : "${(P)var_name1::=${#reply}-1}"

    # Non-selectable lines   Hops to jump with [ and ]   Local anchors
    reply2=( )               reply3=( 1 )                reply4=( move_up_${mod}_${ice} move_down_${mod}_${ice} )
}

-zcrasis_generator_B() {
    -zcrasis_compose

    # Non-selectable lines   Hops to jump with [ and ]   Local anchors
    reply2=( )               reply3=( 1 )                reply4=( )
}

-zcrasis_generator_DBG() {
    reply=( "${ZCR_DEBUG_MSGS[@]}" )

    # Non-selectable lines   Hops to jump with [ and ]   Local anchors
    reply2=( )               reply3=( 1 )                reply4=( )
}

-zcrasis_reload() {
    local id="$1" msg
    float -F 2 sum=0.0
    local -a stats

    print "Parsing zshrc..."
    cmdlist=()
    coidx=1
    stats=()

    typeset -F 2 SECONDS=0
    -zcrasis-tokenize-zsh-rc
    stats+=( "Tokenization time: $SECONDS seconds" )
    sum+=SECONDS

    SECONDS=0
    -zcrasis-process-zsh-rc
    stats+=( "Main processing time: $SECONDS seconds" )
    sum+=SECONDS

    SECONDS=0
    -zcrasis-process-zplugin-commands
    stats+=( "Zplugin-commands processing time: $SECONDS seconds" )
    sum+=SECONDS

    for msg in "${stats[@]}"; do
        -zcrasis_dbg_msg "$msg"
    done

    -zcrasis_dbg_msg "Total time: $sum"

    # Called from button?
    [[ -n "$id" ]] && {
        integer i size=$(( ${#cmdlist} / 3 ))

        -zui_std_set_mod_factor 2 "$size"

        local rtext=","
        for (( i=1; i<=size; ++ i )); do
            rtext+="mod2_ice${i},"
        done

        reply=( "$rtext" "" )
    } || reply=()
}

-zcrasis_dbg_msg "ZSH version: $ZSH_VERSION ($ZSH_PATCHLEVEL), machine: $CPUTYPE $VENDOR $OSTYPE, LANG: $LANG"
-zcrasis_dbg_msg ""
-zcrasis_reload

# Create needed local parameters
integer i
for (( i=1; i<=${#cmdlist}/3; i++ )); do
    local my_mod2_ice${i}_size="0"
done

# Don't reset current segment on jump
ZUI[reset_current_segment]="no"

## Start application ##
zui-event-loop 1:-zcrasis_generator_0 $(( ${#cmdlist} / 3 )):-zcrasis_generator_A \
               0:-zcrasis_generator_B 0:-zcrasis_generator_DBG

-zui_std_cleanup serialize

return 0

# vim:ft=zsh

# -*- mode: shell-script -*-
# Started from Zle or from command line
#
# Copyright (c) 2017 Sebastian Gniazdowski

-zui_std_cleanup deserialize:"zplugin-crasis"
-zui_std_init app:"zplugin-crasis" app_name:"Zplugin-Crasis"
emulate -LR zsh -o extendedglob -o typesetsilent -o warncreateglobal
-zui_std_init2

-zui_std_store_default_app_config b:text_mode off
-zui_std_store_default_app_config b:text_select off
-zui_std_store_default_app_config b:border 1
-zui_std_store_default_app_config b:top_anchors 0  # no top-anchors

#
# CONSTANTS
#

local -A TOKEN_TYPES

TOKEN_TYPES=(

  # Precommand

  'builtin'     1
  'command'     1
  'exec'        1
  'nocorrect'   1
  'noglob'      1
  'pkexec'      1

  # Control flow
  # Tokens that at "command position" are followed by a command

  $'\x7b'   2 # {
  $'\x28'   2 # (
  '()'      2
  'while'   2
  'until'   2
  'if'      2
  'then'    2
  'elif'    2
  'else'    2
  'do'      2
  'time'    2
  'coproc'  2
  '!'       2

  # Command separators

  '|'   3
  '||'  3
  ';'   3
  '&'   3
  '&&'  3
  '|&'  3
  '&!'  3
  '&|'  3
)
#
# PARAMETERS
#

# Document to process
local zshrc_path="${ZDOTDIR:-$HOME}/.zshrc" zshrc

# The bits returned by -zplg-process-buffer
local token prev_token spaces prev_spaces next_token next_spaces

# Command detection
integer at_command=1 in_zplugin=0

# Functions
local fun_name
integer next_fun=0 cur_fun=0 prev_fun=0

# Depths in functions, i.e. -1 not in function, 0 in one function, etc.
integer depth=0 prev_depth=0 fun_depth=-1 anon_depth=-1 descentff=0 descentfa=0

# Nested functions tracking
integer nested_fun=0 next_nested_fun=0 prev_nested_fun=0
local -a fun_stack_depths

# Text and commands data
integer was_zplugin=0 pre_block_end=0 post_block_begin=0
local -A cmd3
local -a commands
integer coidx=1

# Common
local -a mbegin mend match
local MATCH; integer MBEGIN MEND

#
# Load zshrc
#

[[ ! -e "$zshrc_path" ]] && { print "No such file \`$zshrc_path'${ZDOTDIR:+ (using \$ZDOTDIR)}"; return 1; }
[[ ! -f "$zshrc_path" ]] && { print "\`$zshrc_path' isn't a plain, regular file${ZDOTDIR:+ (using \$ZDOTDIR)}"; return 1; }
[[ ! -r "$zshrc_path" ]] && { print "No read permissions to \`$zshrc_path'${ZDOTDIR:+ (using \$ZDOTDIR)}"; return 1; }
[[ ! -w "$zshrc_path" ]] && { print "No write permissions to \`$zshrc_path'${ZDOTDIR:+ (using \$ZDOTDIR)}"; return 1; }
[[ ! -s "$zshrc_path" ]] && { print "File \`$zshrc_path' is empty, aborting"; return 1; }

local zshrc="$(<$zshrc_path)"

# Runs -zcrasis-process-buffer() on $zshrc (containing
# the loaded zshrc)
-zcrasis-tokenize-zsh-rc() {
    -zcrasis-process-buffer "$zshrc" 1
}

# Parses tokens of the loaded zshrc and detects:
# - functions
# - block preceding zplugin commands
# - block with those commands
# - block following them
-zcrasis-process-zsh-rc() {
    integer i j size="${#ZCR_PB_WORDS}"

    for (( i=1; i<=size; ++ i )); do
        token="${ZCR_PB_WORDS[i]}"
        spaces="${ZCR_PB_SPACES[i]}"
        next_token="${ZCR_PB_WORDS[i+1]}"
        next_spaces="${ZCR_PB_SPACES[i+1]}"

        cur_fun=0 prev_fun=0 descentff=0 descentfa=0
        nested_fun=0 prev_nested_fun=0

        (( next_fun )) && { next_fun=0 cur_fun=1 prev_fun=0 anon_depth=-1; }
        (( next_nested_fun )) && { next_nested_fun=0 nested_fun=1 prev_nested_fun=0; }

        # Explicit future-function
        if [[ "$token" = "function" && ( "$fun_depth" -lt 0 ) && ( $anon_depth -lt 0 ) ]]; then
            next_fun=1 cur_fun=0 prev_fun=0 anon_depth=-1
        # Detect top-level prev-function differentiating from anonymous function
        elif [[ "$token" = "()" && ( "$fun_depth" -lt 0 ) && ( $anon_depth -lt 0 ) ]]; then
            if [[ "$spaces" = *$'\n'* || -z "$prev_token" || "${TOKEN_TYPES[$prev_token]}" = [123] ]]; then
                next_fun=0 cur_fun=0 prev_fun=0 anon_depth=$depth
            else
                next_fun=0 cur_fun=0 prev_fun=1 anon_depth=-1
            fi
        # Must be a nested future-function
        elif [[ "$token" = "function" ]]; then
            next_nested_fun=1 nested_fun=0 prev_nested_fun=0
        # Is it a nested prev-function?
        elif [[ "$token" = "()" && "$nested_fun" -eq 0 && "$depth" -gt "$fun_stack_depths[-1]" ]]; then
            if [[ "$spaces" != *$'\n'* && -n "$prev_token" && "${TOKEN_TYPES[$prev_token]}" != [123] ]]; then
                next_nested_fun=0 nested_fun=0 prev_nested_fun=1
            fi
        elif [[ "$token" = "{" ]]; then
            (( ++ depth ))
        elif [[ "$token" = "}" ]]; then
            (( -- depth ))
        fi

        # Check if any final function-flag is raised
        if (( cur_fun )); then
            fun_name="$token"
            fun_depth="$depth"
            fun_stack_depths+=( "$depth" )
        elif (( prev_fun )); then
            fun_name="$prev_token"
            fun_depth="$depth"
            fun_stack_depths+=( "$depth" )
        fi

        # Track nested functions
        if (( nested_fun + prev_nested_fun )); then
            fun_stack_depths+=( "$depth" )
        fi

        # Ascent to function - skip '{'
        if (( fun_depth >= 0 && depth == (fun_depth + 1) )) && [[ "$token" = "{" ]]; then
            :
        # In function
        elif (( fun_depth >= 0 && depth > fun_depth )); then
            if [[ "$token" != [[:blank:]]#\#* ]]; then
                : # do something with a non-comment function token
            fi
            # Handle descent from nested function
            if (( ${#fun_stack_depths} > 0 && depth == fun_stack_depths[-1] && prev_depth == fun_stack_depths[-1] + 1 )); then
                fun_stack_depths[-1]=()
            fi
        # In anonymous-function
        elif (( anon_depth >= 0 && depth > anon_depth )); then
            if (( ${#fun_stack_depths} > 0 && depth == fun_stack_depths[-1] && prev_depth == fun_stack_depths[-1] + 1 )); then
                fun_stack_depths[-1]=()
            fi
        # Descent from function - skip '}'
        elif (( fun_depth >= 0 && depth == fun_depth && prev_depth == fun_depth + 1 )); then
            descentff=1
        # Descent from anon
        elif (( anon_depth >= 0 && depth == anon_depth && prev_depth == anon_depth + 1 )); then
            descentfa=1
        fi

        # Anon function in top-level
        if (( anon_depth >= 0 && fun_depth < 0 )); then
            [[ "$token" != [[:blank:]]#\#* ]] && : # do something with non-comment anon-function token
        fi

        # Check for introduction of Zplugin call
        if [[ "$spaces" = *$'\n'* || -z "$prev_token" || "${TOKEN_TYPES[$prev_token]}" = [123] ]]; then
            at_command=1
            (( in_zplugin )) && post_block_begin=2*i-1
            [[ "$token" != [[:blank:]]#\#* ]] && in_zplugin=0 || { (( in_zplugin )) && in_zplugin=1; }
        fi

        # Command token
        if (( at_command )); then
            at_command=0
            # Zplugin call not in function
            if [[ "$cur_fun" -eq 0 && "$next_token" != "()" && "$fun_stack_depths[-1]" -le "0" ]]; then
                if [[ "$token" = (zplugin|zplg) || ( "$token" = ":" && "$next_token" = (zplugin|zplg) ) ]]; then
                    in_zplugin=1
                    (( was_zplugin == 0 )) && {
                        for (( j=i-1; j >= 1; j -- )); do
                            [[ "${ZCR_PB_WORDS[j]}" != [[:blank:]]#\#* || "${ZCR_PB_SPACES[j+1]}" = *$'\n'*$'\n'* ]] && { pre_block_end=2*j; break; }
                        done
                    }
                    was_zplugin=1

                    # Revive at_command mode if disabled zplugin command
                    [[ "$token" = ":" ]] && at_command=1
                fi
            fi
        fi

        # Late disable of anonymous function
        if (( descentfa )); then
            anon_depth=-1
        # Late disable of normal function
        elif (( descentff )); then
            fun_name=""
            fun_depth=-1
            fun_stack_depths[-1]=()
        # No-function text gathering
        elif (( next_fun == 0 && cur_fun == 0 && prev_fun == 0 && anon_depth < 0 && fun_depth < 0 )); then
            if [[ "$next_token" != "()" || "$next_spaces" = *$'\n'* || "${TOKEN_TYPES[$token]}" = 3 ]]; then
                [[ "$token" != [[:blank:]]#\#* ]] && : # do something with script-body token
            fi
        fi

        # History of state
        prev_depth="$depth"
        prev_token="$token"
        prev_spaces="$spaces"
    done

    (( pre_block_end == 0 )) && pre_block_end=2*(i-1)
    (( post_block_begin == 0 )) && post_block_begin=2*i-1 || {
        # Detect not related trailing comments
        for (( j=(post_block_begin+1)/2-1; j >= 1; j -- )); do
            [[ "${ZCR_PB_WORDS[j]}" = [[:blank:]]#\#* && "${ZCR_PB_WORDS[j]}" != [[:blank:]]#\#[[:blank:]]#zplugin* ]] && {
                post_block_begin=2*j-1
            } || break
        done
    }
}

# Processes block with zplugin commands established in
# -zcrasis-process-zsh-rc() and generates $commands
# array which holds serialized hashes of every zplugin
# invocation, mixed-in additional commands, comments.
-zcrasis-process-zplugin-commands() {
    # From start to end of zplugin block
    for (( i=(pre_block_end/2)+1; i<=(post_block_begin+1)/2-1; ++ i )); do
        token="${ZCR_PB_WORDS[i]}"
        spaces="${ZCR_PB_SPACES[i]}"
        next_token="${ZCR_PB_WORDS[i+1]}"
        next_spaces="${ZCR_PB_SPACES[i+1]}"

        # New command?
        if [[ "$spaces" = *$'\n'* || -z "$prev_token" || "${TOKEN_TYPES[$prev_token]}" = [123] ]]; then
            in_zplugin=1

            if [[ "${cmd3[c]}" = "zplugin" && "${cmd3[sub]}" = "ice" ]]; then
                commands[coidx+1]="${(j: :)${(qkv)cmd3[@]}}"
            elif [[ "${cmd3[c]}" = "zplugin" && "${cmd3[sub]}" != "ice" ]]; then
                commands[coidx+2]="${(j: :)${(qkv)cmd3[@]}}"
                coidx+=3
            fi

            cmd3=()
        fi

        # Command token
        if [[ "$token" = [[:blank:]]#\#* ]]; then
            if (( in_zplugin == 1 )); then
                commands[coidx]+="$token"$'\n'
            else
                cmd3[comment]="$token"
            fi
        elif (( in_zplugin == 1 )); then
            [[ "$token" = (zplugin|zplg) ]] && cmd3[c]="zplugin" || cmd3[c]="$token"
            # Postpone current state to next token
            [[ "$token" = ":" ]] && { cmd3[disabled]=1; (( in_zplugin -- )); }
        elif (( in_zplugin == 2 )); then
            if [[ "${cmd3[c]}" = "zplugin" ]]; then
                [[ "$token" = (ice|load|light|snippet|cdclear|cdreplay) ]] && cmd3[sub]="$token" || { cmd3[sub]="unkn"; cmd3[unkn]="$token"; }
            else
                cmd3[arg_1]="$token"
            fi
        else
            if [[ "${cmd3[sub]}" = "ice" ]]; then
                [[ "$token" = (#b)(from|proto|report|depth|blockf|atload|atpull|atclone|if)(*) ]] && cmd3[${match[1]}]="${match[2]}"
            elif [[ "${cmd3[sub]}" = (load|light) ]]; then
                if (( in_zplugin == 4 )); then
                    cmd3[url]+="/$token"
                else
                    cmd3[url]="$token"
                fi
            elif [[ "${cmd3[sub]}" = "snippet" ]]; then
                [[ "$token" = "-f" ]] && cmd3[-f]="1" || {
                    [[ "$token" = "--command" ]] && cmd3[--command]="1" || {
                        cmd3[url]="$token"
                    }
                }
            elif [[ "${cmd3[sub]}" = "cdclear" ]]; then
                [[ "$token" = "-q" ]] && cmd3[-q]="1"
            elif [[ "${cmd3[sub]}" = "cdreplay" ]]; then
                :
            elif [[ "${cmd3[sub]}" = "unkn" ]]; then
                # Argument following "zplugin <unknown> ..."
                cmd3[arg_$(( in_zplugin - 2 ))]="$token"
            else
                # Argument following "<unknown> <arg_1> ..."
                cmd3[arg_$(( in_zplugin - 1 ))]="$token"
            fi
        fi

        # Advance deeper into "zplugin ..." if it wasn't comment
        #[[ "$token" != [[:blank:]]#\#* ]] && in_zplugin+=1
        in_zplugin+=1
    done

    if [[ -n "${cmd3[c]}" ]];then
        if [[ "${cmd3[c]}" = "zplugin" && "${cmd3[sub]}" = "ice" ]]; then
            commands[coidx+1]="${(j: :)${(qkv)cmd3[@]}}"
        elif [[ "${cmd3[c]}" = "zplugin" && "${cmd3[sub]}" != "ice" ]]; then
            commands[coidx+2]="${(j: :)${(qkv)cmd3[@]}}"
        fi
    fi
}

# Moves given instance ($ice) up, i.e. swaps
# current and previous instance
-zcrasis_move_up() {
    local mod="$1" ice="$2" tmp

    local -a cmd1 cmd2

    cmd1=( "${(@)commands[(ice-1-1)*3+1,(ice-1)*3+1]}" )
    cmd2=( "${(@)commands[(ice-1)*3+1,ice*3+1]}" )

    commands[(ice-1-1)*3+1,(ice-1)*3+1]=( "${cmd2[@]}" )
    commands[(ice-1)*3+1,ice*3+1]=( "${cmd1[@]}" )

    tmp="${ZUI[toggle_dis_${mod}_${ice}]}"
    ZUI[toggle_dis_${mod}_${ice}]="${ZUI[toggle_dis_${mod}_$(( ice-1 ))]}"
    ZUI[toggle_dis_${mod}_$(( ice-1 ))]="$tmp"

    tmp="${ZUI[toggle_command_${mod}_${ice}]}"
    ZUI[toggle_command_${mod}_${ice}]="${ZUI[toggle_command_${mod}_$(( ice-1 ))]}"
    ZUI[toggle_command_${mod}_$(( ice-1 ))]="$tmp"

    tmp="${ZUI[toggle_force_${mod}_${ice}]}"
    ZUI[toggle_force_${mod}_${ice}]="${ZUI[toggle_force_${mod}_$(( ice-1 ))]}"
    ZUI[toggle_force_${mod}_$(( ice-1 ))]="$tmp"

    tmp="${ZUI[toggle_mode_${mod}_${ice}]}"
    ZUI[toggle_mode_${mod}_${ice}]="${ZUI[toggle_mode_${mod}_$(( ice-1 ))]}"
    ZUI[toggle_mode_${mod}_$(( ice-1 ))]="$tmp"
}

# Moves given instance ($ice) down, i.e. swaps
# current and next instance
-zcrasis_move_down() {
    local mod="$1" ice="$2" tmp

    local -a cmd1 cmd2

    cmd1=( "${(@)commands[(ice-1)*3+1,ice*3+1]}" )
    cmd2=( "${(@)commands[(ice-1+1)*3+1,(ice+1)*3+1]}" )

    commands[(ice-1)*3+1,ice*3+1]=( "${cmd2[@]}" )
    commands[(ice-1+1)*3+1,(ice+1)*3+1]=( "${cmd1[@]}" )

    tmp="${ZUI[toggle_dis_${mod}_${ice}]}"
    ZUI[toggle_dis_${mod}_${ice}]="${ZUI[toggle_dis_${mod}_$(( ice+1 ))]}"
    ZUI[toggle_dis_${mod}_$(( ice+1 ))]="$tmp"

    tmp="${ZUI[toggle_command_${mod}_${ice}]}"
    ZUI[toggle_command_${mod}_${ice}]="${ZUI[toggle_command_${mod}_$(( ice+1 ))]}"
    ZUI[toggle_command_${mod}_$(( ice+1 ))]="$tmp"

    tmp="${ZUI[toggle_force_${mod}_${ice}]}"
    ZUI[toggle_force_${mod}_${ice}]="${ZUI[toggle_force_${mod}_$(( ice+1 ))]}"
    ZUI[toggle_force_${mod}_$(( ice+1 ))]="$tmp"

    tmp="${ZUI[toggle_mode_${mod}_${ice}]}"
    ZUI[toggle_mode_${mod}_${ice}]="${ZUI[toggle_mode_${mod}_$(( ice+1 ))]}"
    ZUI[toggle_mode_${mod}_$(( ice+1 ))]="$tmp"
}

# Generator for module 1
-zcrasis_generator_A() {
    local mod="$1" ice="$2" comment
    local -a cmd output
    local -A ice_cmd main_cmd
    local var_name1 var_name2
    local num dis_col mode_col command_col force_col disabled_text

    cmd=( "${(@)commands[(ice-1)*3+1,ice*3+1]}" )
    comment="${cmd[1]}"
    [[ -n "${cmd[2]}" ]] && ice_cmd=( "${(z@)cmd[2]}" )
    [[ -n "${cmd[3]}" ]] && main_cmd=( "${(z@)cmd[3]}" )

    output=()

    # Command number
    num="${(l:2::0:)ice}."

    # "Up", "Down"
    var_name1="my_mod${mod}_ice$(( ice-1 ))_size"
    var_name2="my_mod${mod}_ice$(( ice+1 ))_size"

    if [[ "$ice" -gt 1 ]]; then
        -zui_std_anchor "move_up_${mod}_${ice}" "1-1-${var_name1}" "" ",mod${mod}_ice${ice},mod${mod}_ice$(( ice - 1 ))," "" "${ZUI[YELLOW]}[Up]${ZUI[FMT_END]}" "-zcrasis_move_up $mod $ice" output
    else
        output+=( "[Up]" )
    fi

    if [[ "$ice" -lt $(( ${#commands} / 3 )) ]]; then
        -zui_std_anchor "move_down_${mod}_${ice}" "1+1+${var_name2}" "" ",mod${mod}_ice${ice},mod${mod}_ice$(( ice + 1 ))," "" "${ZUI[YELLOW]}[Down]${ZUI[FMT_END]}" "-zcrasis_move_down $mod $ice" output
    else
        output+=( "[Down]" )
    fi

    # "DISABLED" or "Enabled"
    [[ -z "${ZUI[toggle_dis_${mod}_${ice}]}" ]] && ZUI[toggle_dis_${mod}_${ice}]="${main_cmd[disabled]:-0}" || main_cmd[disabled]=${ZUI[toggle_dis_${mod}_${ice}]}
    -zui_util_map_bools "[[ \"${ZUI[toggle_dis_${mod}_${ice}]}\" = 1 ]]" "dis_col" "${ZUI[RED]}" "${ZUI[GREEN]}"
    -zui_util_map_bools "[[ \"${ZUI[toggle_dis_${mod}_${ice}]}\" = 1 ]]" "disabled_text" "DISABLED" "Enabled"

    -zui_std_rc_button "toggle_dis_${mod}_${ice}" "${dis_col}${disabled_text}${ZUI[FMT_END]}" '(( ZUI[toggle_dis_'"${mod}_${ice}"']=1-${ZUI[toggle_dis_'"${mod}_${ice}"']} )); -zui_std_fly_mod_regen '"$mod $ice"'; internal=1' output

    reply=()
    if [[ "${main_cmd[sub]}" = "snippet" ]]; then
        #
        # command on/off
        #

        [[ -z "${ZUI[toggle_command_${mod}_${ice}]}" ]] && ZUI[toggle_command_${mod}_${ice}]="${main_cmd[--command]:-0}" || main_cmd[--command]=${ZUI[toggle_command_${mod}_${ice}]}
        -zui_util_map_bools "[[ \"${ZUI[toggle_command_${mod}_${ice}]}\" = 1 ]]" "command_col" "${ZUI[BG_BLUE]}" "${ZUI[GREEN]}"
        local command_text="${command_col}as-command${ZUI[FMT_END]}"
        -zui_std_rc_button "toggle_command_${mod}_${ice}" "$command_text" '(( ZUI[toggle_command_'"${mod}_${ice}"']=1-${ZUI[toggle_command_'"${mod}_${ice}"']} )); -zui_std_fly_mod_regen '"$mod $ice"'; internal=1' output

        #
        # force on/off
        #

        [[ -z "${ZUI[toggle_force_${mod}_${ice}]}" ]] && ZUI[toggle_force_${mod}_${ice}]="${main_cmd[-f]:-0}" || main_cmd[-f]=${ZUI[toggle_force_${mod}_${ice}]}
        -zui_util_map_bools "[[ \"${ZUI[toggle_force_${mod}_${ice}]}\" = 1 ]]" "force_col" "${ZUI[BG_BLUE]}" "${ZUI[GREEN]}"
        local force_text="${force_col}force${ZUI[FMT_END]}"
        -zui_std_rc_button "toggle_force_${mod}_${ice}" "$force_text" '(( ZUI[toggle_force_'"${mod}_${ice}"']=1-${ZUI[toggle_force_'"${mod}_${ice}"']} )); -zui_std_fly_mod_regen '"$mod $ice"'; internal=1' output

        #
        # Document
        #

        reply+=( "$num ${output[1]} ${output[2]} S ${ZUI[MAGENTA]}${main_cmd[url]}${ZUI[FMT_END]}" )
        reply+=( "${output[3]} ${output[4]} ${output[5]}" )
    elif [[ "${main_cmd[sub]}" = (light|load) ]]; then
        #
        # Mode: light or normal ("load")
        #

        [[ -z "${ZUI[toggle_mode_${mod}_${ice}]}" ]] && ZUI[toggle_mode_${mod}_${ice}]="${main_cmd[sub]}" || main_cmd[sub]=${ZUI[toggle_mode_${mod}_${ice}]}
        -zui_util_map_bools "[[ \"${ZUI[toggle_mode_${mod}_${ice}]}\" = light ]]" "mode_col" "${ZUI[YELLOW]}" "${ZUI[GREEN]}"
        local mode_text="Mode: ${mode_col}${main_cmd[sub]}${ZUI[FMT_END]}"
        -zui_std_rc_button "toggle_mode_${mod}_${ice}" "$mode_text" '[[ ${ZUI[toggle_mode_'"${mod}_${ice}"']} = light ]] && ZUI[toggle_mode_'"${mod}_${ice}"']=load || ZUI[toggle_mode_'"${mod}_${ice}"']=light; -zui_std_fly_mod_regen '"$mod $ice"'; internal=1' output

        #
        # Document
        #

        reply+=( "$num ${output[1]} ${output[2]} P ${ZUI[CYAN]}${main_cmd[url]}${ZUI[FMT_END]}" )
        reply+=( "${output[3]} ${output[4]}" )
    elif [[ "${main_cmd[sub]}" = "cdreplay" ]]; then
        reply+=( "$num ${output[1]} ${output[2]} cdreplay" )
        reply+=( "${output[3]}" )
    elif [[ "${main_cmd[sub]}" = "cdclear" ]]; then
        reply+=( "$num ${output[1]} ${output[2]} cdclear" )
        reply+=( "${output[3]}" )
    else
        reply+=( "Unknown command" )
    fi

    # Instead of debugging ZUI, I've added '-1' here
    var_name1="my_mod${mod}_ice${ice}_size"
    : "${(P)var_name1::=${#reply}-1}"

    # Non-selectable lines   Hops to jump with [ and ]   Local anchors
    reply2=( )               reply3=( 1 )                reply4=( move_up_${mod}_${ice} move_down_${mod}_${ice} )
}

print "Parsing zshrc..."
-zcrasis-tokenize-zsh-rc
-zcrasis-process-zsh-rc
-zcrasis-process-zplugin-commands
# Create needed local parameters
integer i
for (( i=1; i<=${#commands}/3; i++ )); do
    local my_mod1_ice${i}_size="0"
done

# Don't reset current segment on jump
ZUI[reset_current_segment]="no"

## Start application ##
zui-event-loop $(( ${#commands} / 3 )):-zcrasis_generator_A

-zui_std_cleanup serialize

return 0

# vim:ft=zsh

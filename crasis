# -*- mode: shell-script -*-
# Started from Zle or from command line
#
# Copyright (c) 2017 Sebastian Gniazdowski

-zui_std_cleanup deserialize:"zplugin-crasis"
-zui_std_init app:"zplugin-crasis" app_name:"Zplugin-Crasis"
emulate -LR zsh -o extendedglob -o typesetsilent -o warncreateglobal
-zui_std_init2

-zui_std_store_default_app_config b:text_mode off
-zui_std_store_default_app_config b:text_select off
-zui_std_store_default_app_config b:border 1
-zui_std_store_default_app_config b:top_anchors 0  # no top-anchors

# Already autoloaded in *.plugin.zsh, here it's for Zshelldoc
autoload -- -zcrasis-process-buffer

# Debug array, for debug view
local -a ZCR_DEBUG_MSGS

# Append message(s) to the debug view
-zcrasis_dbg_msg() { ZCR_DEBUG_MSGS+=( "$*" ); }
-zcrasis_dbg_msg_arr() { ZCR_DEBUG_MSGS+=( "$@" ); }

# Initial debug message
-zcrasis_dbg_msg "ZSH version: $ZSH_VERSION ($ZSH_PATCHLEVEL), machine: $CPUTYPE $VENDOR $OSTYPE, LANG: $LANG"
if [[ ${+ZPLGM} = 1 ]]; then
    -zcrasis_dbg_msg "Zplugin version: <ZPLGVERSION>, Zplugin-Crasis version: <ZCRVERSION>"
    -zcrasis_dbg_msg "Zplugin BIN_DIR: ${ZPLGM[BIN_DIR]/$HOME/~}, HOME_DIR: ${ZPLGM[HOME_DIR]/$HOME/~}, PLUGINS_DIR: ${ZPLGM[PLUGINS_DIR]/$HOME/~}, COMPLETIONS_DIR: ${ZPLGM[COMPLETIONS_DIR]/$HOME/~}"
else
    -zcrasis_dbg_msg "${ZUI[RED]}Zplugin not loaded${ZUI[FMT_END]}"
fi

-zcrasis_dbg_msg ""
-zcrasis_dbg_msg_arr "Active plugins:" "${ZPLG_REGISTERED_PLUGINS[@]/(#s)/ }"
-zcrasis_dbg_msg ""

#
# CONSTANTS
#

local -A TOKEN_TYPES

TOKEN_TYPES=(

  # Precommand

  'builtin'     1
  'command'     1
  'exec'        1
  'nocorrect'   1
  'noglob'      1
  'pkexec'      1

  # Control flow
  # Tokens that at "command position" are followed by a command

  $'\x7b'   2 # {
  $'\x28'   2 # (
  '()'      2
  'while'   2
  'until'   2
  'if'      2
  'then'    2
  'elif'    2
  'else'    2
  'do'      2
  'time'    2
  'coproc'  2
  '!'       2

  # Command separators

  '|'   3
  '||'  3
  ';'   3
  '&'   3
  '&&'  3
  '|&'  3
  '&!'  3
  '&|'  3
)

local -a chosen_plugins
chosen_plugins=(
    "<Gold Plugins Collection>"
    "djui/alias-tips"
    "zdharma/fast-syntax-highlighting"
    "zdharma/history-search-multi-word"
    "zdharma/zredis"
    "zsh-users/zsh-autosuggestions"
    "zsh-users/zsh-completions"
    "zsh-users/zsh-history-substring-search"
    "zsh-users/zsh-syntax-highlighting"
)

#
# PARAMETERS
#

# Document to process
local zshrc_path="${ZDOTDIR:-$HOME}/.zshrc" zshrc

# The bits returned by -zplg-process-buffer
local token prev_token spaces prev_spaces next_token next_spaces

# Command detection
integer at_command=1 in_zplugin=0

# Functions
local fun_name
integer next_fun=0 cur_fun=0 prev_fun=0

# Depths in functions, i.e. -1 not in function, 0 in one function, etc.
integer depth=0 prev_depth=0 fun_depth=-1 anon_depth=-1 descentff=0 descentfa=0

# Nested functions tracking
integer nested_fun=0 next_nested_fun=0 prev_nested_fun=0
local -a fun_stack_depths

# Text and commands data
integer was_zplugin=0 pre_block_end=0 post_block_begin=0
local -A cmd3
local -a cmdlist
integer coidx=1
local leading_spaces

# Common
local -a mbegin mend match
local MATCH; integer MBEGIN MEND
local internal # to mark inline action as no-ZUI-restart
local tmp
typeset -g REPLY
typeset -ga reply

# -zcrasis-process-buffer output parameters, declare
# them to prevent globals from being created
local -a ZCR_PB_WORDS ZCR_PB_SPACES ZCR_PB_WORDS_BEGINNINGS ZCR_PB_ALL

#
# Examine zshrc
#

[[ ! -e "$zshrc_path" ]] && { print "No such file \`$zshrc_path'${ZDOTDIR:+ (using \$ZDOTDIR)}"; return 1; }
[[ ! -f "$zshrc_path" ]] && { print "\`$zshrc_path' isn't a plain, regular file${ZDOTDIR:+ (using \$ZDOTDIR)}"; return 1; }
[[ ! -r "$zshrc_path" ]] && { print "No read permissions to \`$zshrc_path'${ZDOTDIR:+ (using \$ZDOTDIR)}"; return 1; }
[[ ! -w "$zshrc_path" ]] && { print "No write permissions to \`$zshrc_path'${ZDOTDIR:+ (using \$ZDOTDIR)}"; return 1; }
[[ ! -s "$zshrc_path" ]] && { print "File \`$zshrc_path' is empty, aborting"; return 1; }

local zshrc

# Runs -zcrasis-process-buffer() on $zshrc (containing
# the loaded zshrc)
-zcrasis-tokenize-zsh-rc() {
    -zcrasis-process-buffer "$zshrc" 1
}

# Parses tokens of the loaded zshrc and detects:
# - functions
# - block preceding zplugin commands
# - block with those commands
# - block following them
#
# Uses parameters filled by -zcrasis-process-buffer:
# - $ZCR_PB_WORDS - tokens
# - $ZCR_PB_SPACES - spaces in front of each token, +1 at the end
-zcrasis-process-zsh-rc() {
    integer i j size="${#ZCR_PB_WORDS}"

    for (( i=1; i<=size; ++ i )); do
        token="${ZCR_PB_WORDS[i]}"
        spaces="${ZCR_PB_SPACES[i]}"
        next_token="${ZCR_PB_WORDS[i+1]}"
        next_spaces="${ZCR_PB_SPACES[i+1]}"

        cur_fun=0 prev_fun=0 descentff=0 descentfa=0
        nested_fun=0 prev_nested_fun=0

        (( next_fun )) && { next_fun=0 cur_fun=1 prev_fun=0 anon_depth=-1; }
        (( next_nested_fun )) && { next_nested_fun=0 nested_fun=1 prev_nested_fun=0; }

        # Explicit future-function
        if [[ "$token" = "function" && ( "$fun_depth" -lt 0 ) && ( $anon_depth -lt 0 ) ]]; then
            next_fun=1 cur_fun=0 prev_fun=0 anon_depth=-1
        # Detect top-level prev-function differentiating from anonymous function
        elif [[ "$token" = "()" && ( "$fun_depth" -lt 0 ) && ( $anon_depth -lt 0 ) ]]; then
            if [[ "$spaces" = *$'\n'* || -z "$prev_token" || "${TOKEN_TYPES[$prev_token]}" = [123] ]]; then
                next_fun=0 cur_fun=0 prev_fun=0 anon_depth=$depth
            else
                next_fun=0 cur_fun=0 prev_fun=1 anon_depth=-1
            fi
        # Must be a nested future-function
        elif [[ "$token" = "function" ]]; then
            next_nested_fun=1 nested_fun=0 prev_nested_fun=0
        # Is it a nested prev-function?
        elif [[ "$token" = "()" && "$nested_fun" -eq 0 && "$depth" -gt "$fun_stack_depths[-1]" ]]; then
            if [[ "$spaces" != *$'\n'* && -n "$prev_token" && "${TOKEN_TYPES[$prev_token]}" != [123] ]]; then
                next_nested_fun=0 nested_fun=0 prev_nested_fun=1
            fi
        elif [[ "$token" = "{" ]]; then
            (( ++ depth ))
        elif [[ "$token" = "}" ]]; then
            (( -- depth ))
        fi

        # Check if any final function-flag is raised
        if (( cur_fun )); then
            fun_name="$token"
            fun_depth="$depth"
            fun_stack_depths+=( "$depth" )
        elif (( prev_fun )); then
            fun_name="$prev_token"
            fun_depth="$depth"
            fun_stack_depths+=( "$depth" )
        fi

        # Track nested functions
        if (( nested_fun + prev_nested_fun )); then
            fun_stack_depths+=( "$depth" )
        fi

        # Ascent to function - skip '{'
        if (( fun_depth >= 0 && depth == (fun_depth + 1) )) && [[ "$token" = "{" ]]; then
            :
        # In function
        elif (( fun_depth >= 0 && depth > fun_depth )); then
            if [[ "$token" != [[:blank:]]#\#* ]]; then
                : # do something with a non-comment function token
            fi
            # Handle descent from nested function
            if (( ${#fun_stack_depths} > 0 && depth == fun_stack_depths[-1] && prev_depth == fun_stack_depths[-1] + 1 )); then
                fun_stack_depths[-1]=()
            fi
        # In anonymous-function
        elif (( anon_depth >= 0 && depth > anon_depth )); then
            if (( ${#fun_stack_depths} > 0 && depth == fun_stack_depths[-1] && prev_depth == fun_stack_depths[-1] + 1 )); then
                fun_stack_depths[-1]=()
            fi
        # Descent from function - skip '}'
        elif (( fun_depth >= 0 && depth == fun_depth && prev_depth == fun_depth + 1 )); then
            descentff=1
        # Descent from anon
        elif (( anon_depth >= 0 && depth == anon_depth && prev_depth == anon_depth + 1 )); then
            descentfa=1
        fi

        # Anon function in top-level
        if (( anon_depth >= 0 && fun_depth < 0 )); then
            [[ "$token" != [[:blank:]]#\#* ]] && : # do something with non-comment anon-function token
        fi

        # Check for introduction of Zplugin call
        if [[ "$spaces" = *$'\n'* || -z "$prev_token" || "${TOKEN_TYPES[$prev_token]}" = [123] ]]; then
            at_command=1
            (( in_zplugin )) && post_block_begin=2*i-1
            [[ "$token" != [[:blank:]]#\#* ]] && in_zplugin=0 || { (( in_zplugin )) && in_zplugin=1; }
        fi

        # Command token
        if (( at_command )); then
            at_command=0
            # Zplugin call not in function
            if [[ "$cur_fun" -eq 0 && "$next_token" != "()" && "$fun_stack_depths[-1]" -le "0" ]]; then
                if [[ "$token" = (zplugin|zplg) || ( "$token" = ":" && "$next_token" = (zplugin|zplg) ) ]]; then
                    in_zplugin=1
                    (( was_zplugin == 0 )) && {
                        for (( j=i-1; j >= 1; j -- )); do
                            [[ "${ZCR_PB_WORDS[j]}" != [[:blank:]]#\#* || "${ZCR_PB_SPACES[j+1]}" = *$'\n'*$'\n'* ]] && { pre_block_end=2*j; break; }
                        done
                    }
                    was_zplugin=1

                    # Revive at_command mode if disabled zplugin command
                    [[ "$token" = ":" ]] && at_command=1
                fi
            fi
        fi

        # Late disable of anonymous function
        if (( descentfa )); then
            anon_depth=-1
        # Late disable of normal function
        elif (( descentff )); then
            fun_name=""
            fun_depth=-1
            fun_stack_depths[-1]=()
        # No-function text gathering
        elif (( next_fun == 0 && cur_fun == 0 && prev_fun == 0 && anon_depth < 0 && fun_depth < 0 )); then
            if [[ "$next_token" != "()" || "$next_spaces" = *$'\n'* || "${TOKEN_TYPES[$token]}" = 3 ]]; then
                [[ "$token" != [[:blank:]]#\#* ]] && : # do something with script-body token
            fi
        fi

        # History of state
        prev_depth="$depth"
        prev_token="$token"
        prev_spaces="$spaces"
    done

    (( pre_block_end == 0 )) && pre_block_end=2*(i-1)
    (( post_block_begin == 0 )) && post_block_begin=2*i-1 || {
        # Detect not related trailing comments
        for (( j=(post_block_begin+1)/2-1; j >= 1; j -- )); do
            [[ "${ZCR_PB_WORDS[j]}" = [[:blank:]]#\#* && "${ZCR_PB_WORDS[j]}" != [[:blank:]]#\#[[:blank:]]#zplugin* ]] && {
                post_block_begin=2*j-1
            } || break
        done
    }
}

# Processes block with zplugin commands established in
# -zcrasis-process-zsh-rc() and generates $cmdlist
# array which holds serialized hashes of every zplugin
# invocation, mixed-in additional commands, comments.
#
# Uses parameters filled by -zcrasis-process-buffer:
# - $ZCR_PB_WORDS - tokens
# - $ZCR_PB_SPACES - spaces in front of each token, +1 at the end
-zcrasis-process-zplugin-commands() {
    integer i
    cmd3=()
    # From start to end of zplugin block
    for (( i=(pre_block_end/2)+1; i<=(post_block_begin+1)/2-1; ++ i )); do
        token="${ZCR_PB_WORDS[i]}"
        spaces="${ZCR_PB_SPACES[i]}"
        next_token="${ZCR_PB_WORDS[i+1]}"
        next_spaces="${ZCR_PB_SPACES[i+1]}"

        # New command?
        if [[ "$spaces" = *$'\n'* || -z "$prev_token" || "${TOKEN_TYPES[$prev_token]}" = [123] ]]; then
            in_zplugin=1

            if [[ "${cmd3[c]}" = "zplugin" && "${cmd3[sub]}" = "ice" ]]; then
                cmdlist[coidx+1]="${(j: :)${(qkv)cmd3[@]}}"
            elif [[ "${cmd3[c]}" = "zplugin" && "${cmd3[sub]}" != "ice" ]]; then
                cmdlist[coidx+2]="${(j: :)${(qkv)cmd3[@]}}"
                coidx+=3
            else
                # Don't increase coidx untill we get some command.
                # This causes preceding comments to accumulate.
                if [[ -n "${cmd3[c]}" ]]; then
                    # Custom command
                    cmdlist[coidx+2]="${(j: :)${(qkv)cmd3[@]}}"
                    coidx+=3
                fi
            fi

            cmd3=()
        fi

        # Command token
        if [[ "$token" = [[:blank:]]#\#* ]]; then
            if (( in_zplugin == 1 )); then
                cmdlist[coidx]="${cmdlist[coidx]%%[[:space:]]##}"
                cmdlist[coidx]+="$spaces$token$next_spaces"
            else
                cmd3[comment]="$spaces$token"
            fi
        elif (( in_zplugin == 1 )); then
            [[ "$token" = (zplugin|zplg) ]] && cmd3[c]="zplugin" || cmd3[c]="$token"
            # Postpone current state to next token
            [[ "$token" = ":" ]] && { cmd3[disabled]=1; (( in_zplugin -- )); }
        elif (( in_zplugin == 2 )); then
            if [[ "${cmd3[c]}" = "zplugin" ]]; then
                [[ "$token" = (ice|load|light|snippet|cdclear|cdreplay) ]] && cmd3[sub]="$token" || { cmd3[sub]="unkn"; cmd3[unkn]="$token"; }
            else
                cmd3[arg_1]="$token"
            fi
        else
            if [[ "${cmd3[sub]}" = "ice" ]]; then
                [[ "$token" = (#b)(from|proto|report|depth|blockf|atload|atpull|atclone|if)(*) ]] && cmd3[${match[1]}]="${match[2]}"
            elif [[ "${cmd3[sub]}" = (load|light) ]]; then
                if (( in_zplugin == 4 )); then
                    cmd3[url]+="/$token"
                else
                    cmd3[url]="$token"
                fi
            elif [[ "${cmd3[sub]}" = "snippet" ]]; then
                [[ "$token" = "-f" ]] && cmd3[-f]="1" || {
                    [[ "$token" = "--command" ]] && cmd3[--command]="1" || {
                        cmd3[url]="$token"
                    }
                }
            elif [[ "${cmd3[sub]}" = "cdclear" ]]; then
                [[ "$token" = "-q" ]] && cmd3[-q]="1"
            elif [[ "${cmd3[sub]}" = "cdreplay" ]]; then
                :
            elif [[ "${cmd3[sub]}" = "unkn" ]]; then
                # Argument following "zplugin <unknown> ..."
                cmd3[arg_$(( in_zplugin - 2 ))]="$token"
            else
                # Argument following "<unknown> <arg_1> ..."
                cmd3[arg_$(( in_zplugin - 1 ))]="$token"
            fi
        fi

        # Advance deeper into "zplugin ..." if it wasn't comment
        #[[ "$token" != [[:blank:]]#\#* ]] && in_zplugin+=1
        in_zplugin+=1
    done

    # Spaces before first comment or command - not moved with command
    if [[ -n "${cmdlist[1]}" ]]; then
        cmdlist[1]="${cmdlist[1]##(#m)[[:space:]]##}"
        leading_spaces="$MATCH"
    else
        leading_spaces="${ZCR_PB_SPACES[(pre_block_end/2)+1]}"
    fi

    if [[ -n "${cmd3[c]}" ]];then
        if [[ "${cmd3[c]}" = "zplugin" && "${cmd3[sub]}" = "ice" ]]; then
            cmdlist[coidx+1]="${(j: :)${(qkv)cmd3[@]}}"
        elif [[ "${cmd3[c]}" = "zplugin" && "${cmd3[sub]}" != "ice" ]]; then
            cmdlist[coidx+2]="${(j: :)${(qkv)cmd3[@]}}"
        fi
        -zcrasis_dbg_msg "Zplugin block in zshrc has $(( (coidx + 2) / 3 )) commands (not counting \`zplugin ice ...')"
    else
        -zcrasis_dbg_msg "Zplugin block in zshrc has $(( (coidx-1) / 3 )) commands (not counting \`zplugin ice ...')"
    fi

    -zcrasis_dbg_msg ""
}

# Swaps two variables given by name. Uses (P) substitution
# flag, can swap e.g. hash entries. For example:
#   local -A hash_arr=( a b c d )
#   -zcrasis_util_swap 'hash_arr[a]' 'hash_arr[b]'
#
# $1 - name of first variable to swap
# $2 - name of second variable to swap
-zcrasis_util_swap() {
    local __var_name1="$1" __var_name2="$2" __tmp
    tmp="${(P)__var_name1}"
    : ${(P)__var_name1::=${(P)__var_name2}}
    : ${(P)__var_name2::=$tmp}
}

# Moves given instance ($2) up, i.e. swaps
# current and previous instance
#
# $1 - module index (will be 2)
# $2 - instance index
-zcrasis_action_move_up() {
    local mod="$1" ice="$2" tmp

    local -a cmd1 cmd2

    cmd1=( "${(@)cmdlist[(ice-1-1)*3+1,(ice-1)*3]}" )
    cmd2=( "${(@)cmdlist[(ice-1)*3+1,ice*3]}" )

    cmdlist[(ice-1-1)*3+1,(ice-1)*3]=( "${cmd2[@]}" )
    cmdlist[(ice-1)*3+1,ice*3]=( "${cmd1[@]}" )

    noglob -zcrasis_util_swap ZUI[toggle_dis_${mod}_${ice}] ZUI[toggle_dis_${mod}_$(( ice-1 ))]
    noglob -zcrasis_util_swap ZUI[toggle_command_${mod}_${ice}] ZUI[toggle_command_${mod}_$(( ice-1 ))]
    noglob -zcrasis_util_swap ZUI[toggle_force_${mod}_${ice}] ZUI[toggle_force_${mod}_$(( ice-1 ))]
    noglob -zcrasis_util_swap ZUI[toggle_mode_${mod}_${ice}] ZUI[toggle_mode_${mod}_$(( ice-1 ))]
}

# Moves given instance ($ice) down, i.e. swaps
# current and next instance
#
# $1 - module index (will be 2)
# $2 - instance index
-zcrasis_action_move_down() {
    local mod="$1" ice="$2" tmp

    local -a cmd1 cmd2

    cmd1=( "${(@)cmdlist[(ice-1)*3+1,ice*3]}" )
    cmd2=( "${(@)cmdlist[(ice-1+1)*3+1,(ice+1)*3]}" )

    cmdlist[(ice-1)*3+1,ice*3]=( "${cmd2[@]}" )
    cmdlist[(ice-1+1)*3+1,(ice+1)*3]=( "${cmd1[@]}" )

    noglob -zcrasis_util_swap ZUI[toggle_dis_${mod}_${ice}] ZUI[toggle_dis_${mod}_$(( ice+1 ))]
    noglob -zcrasis_util_swap ZUI[toggle_command_${mod}_${ice}] ZUI[toggle_command_${mod}_$(( ice+1 ))]
    noglob -zcrasis_util_swap ZUI[toggle_force_${mod}_${ice}] ZUI[toggle_force_${mod}_$(( ice+1 ))]
    noglob -zcrasis_util_swap ZUI[toggle_mode_${mod}_${ice}] ZUI[toggle_mode_${mod}_$(( ice+1 ))]
}

# Enters or leaves preview view. It basically sets
# preview module's instance to be created, once.
# At the same time, plugin list module is set to 0
# instances.
-zcrasis_action_preview() {
    -zui_std_set_mod_factor 4 0
    ZUI[in_debug]=0
    if [[ "${ZUI[in_preview]}" != 1 ]]; then
        -zui_std_set_mod_factor 2 0
        -zui_std_set_mod_factor 3 1
        ZUI[in_preview]=1
    else
        -zui_std_set_mod_factor 2 $(( ${#cmdlist} / 3 ))
        -zui_std_set_mod_factor 3 0
        ZUI[in_preview]=0
    fi

    # Regenerate menu and preview module
    reply=( ",mod1_ice1,mod3_ice1," "" )
}

# Enters or leaves debug view.
-zcrasis_action_debug_view() {
    -zui_std_set_mod_factor 3 0
    ZUI[in_preview]=0

    if [[ "${ZUI[in_debug]}" != 1 ]]; then
        -zui_std_set_mod_factor 2 0
        -zui_std_set_mod_factor 4 1
        ZUI[in_debug]=1

        ZCR_DEBUG_MSGS=( "${ZCR_DEBUG_MSGS[@]/<ZSHRCSIZE>/${#zshrc}}" )
        ZCR_DEBUG_MSGS=( "${ZCR_DEBUG_MSGS[@]/<ZSHRCLINES>/${#${(f@)zshrc}}}" )

        { local ver="$(<${ZPLGM[BIN_DIR]}/.git/refs/heads/master)" } 2>/dev/null
        [[ -z "$ver" ]] && ver="unknown (no .git/refs/heads/master)" || ver="${ver[1,7]}"
        ZCR_DEBUG_MSGS=( "${ZCR_DEBUG_MSGS[@]/<ZPLGVERSION>/$ver}" )

        { local ver="$(<${ZPLGM[PLUGINS_DIR]}/zdharma---zplugin-crasis/.git/refs/heads/master)" } 2>/dev/null
        [[ -z "$ver" ]] && ver="unknown (no .git/refs/heads/master)" || ver="${ver[1,7]}"
        ZCR_DEBUG_MSGS=( "${ZCR_DEBUG_MSGS[@]/<ZCRVERSION>/$ver}" )
    else
        -zui_std_set_mod_factor 2 $(( ${#cmdlist} / 3 ))
        -zui_std_set_mod_factor 4 0
        ZUI[in_debug]=0
    fi

    # Regenerate menu and debug module
    reply=( ",mod1_ice1,mod4_ice1," "" )
}

# Removes given entry from $cmdlist and orders
# full regeneration of commands-section
#
# $1 - widget id
# $2 - module's index
# $3 - module's instance index
-zcrasis_action_delete() {
    local id="$1" mod="$2" ice="$3"
    cmdlist[(ice-1)*3+1,ice*3]=()

    local rtext=","
    integer i size=$(( ${#cmdlist} / 3 ))

    -zui_std_set_mod_factor 2 "$size"

    -zcrasis_clear_visual_state

    for (( i=1; i<=size; ++ i )); do
        rtext+="mod${mod}_ice${i},"
    done

    reply=( "$rtext" "" )
}

# Enables ability to delete entries - adds [X] button
# to each plugin, snippet, etc.
-zcrasis_action_delete_mode() {
    if [[ -n "${ZUI[zc_delete_mode]}" ]]; then
        (( ZUI[zc_delete_mode] = 1 - ZUI[zc_delete_mode] ))
    else
        ZUI[zc_delete_mode]=1
    fi

    -zcrasis_refresh2_all_string

    reply=( "$REPLY" "" )
}

# Enables ability to edit entries - strings with plugin name,
# snippet url, etc. turn into text fields for manual editing.
-zcrasis_action_edit_mode() {
    if [[ -n "${ZUI[zc_edit_mode]}" ]]; then
        (( ZUI[zc_edit_mode] = 1 - ZUI[zc_edit_mode] ))
    else
        ZUI[zc_edit_mode]=1
    fi

    -zcrasis_refresh2_all_string
    reply=( "$REPLY" "" )
}

# Switches the entry list to compact-mode. In this mode,
# only a single line per plugin/snippet/etc. is displayed.
-zcrasis_action_compact_mode() {
    if [[ -n "${ZUI[zc_compact_mode]}" ]]; then
        (( ZUI[zc_compact_mode] = 1 - ZUI[zc_compact_mode] ))
    else
        ZUI[zc_compact_mode]=1
    fi

    -zcrasis_refresh2_all_string
    reply=( "$REPLY" "" )
}

# Returns string that when passed to ZUI causes to regenerate
# all instances of module 2 and module 1 (the menu bar)
-zcrasis_refresh2_all_string() {
    local rtext=",mod1_ice1,"
    integer i size=$(( ${#cmdlist} / 3 ))

    for (( i=1; i<=size; ++ i )); do
        rtext+="mod2_ice${i},"
    done

    REPLY="$rtext"
}

# Constructs text with zplugin commands, optionally
# including original Zshrc blocks (in order to create
# full zshrc).
#
# $1 - zero or 1 - whether to include comments
# $2 - zero or 1 - whether to generate complete zshrc
#
# $reply - lines of created code
-zcrasis_compose() {
    local with_comments="$1" whole="$2"
    local buf="" tmp comment
    integer i size=$(( ${#commands} / 3 ))
    local -a cmd
    local -A ice_cmd main_cmd

    [[ "$whole" = "1" ]] && buf="${(j::)ZCR_PB_ALL[1,pre_block_end]}$leading_spaces"

    for (( i=1; i<=size; ++ i )); do
        cmd=( "${(@)cmdlist[(i-1)*3+1,i*3]}" )
        comment="${cmd[1]}"
        ice_cmd=() main_cmd=()
        [[ -n "${cmd[2]}" ]] && ice_cmd=( "${(z@)cmd[2]}" )
        [[ -n "${cmd[3]}" ]] && main_cmd=( "${(z@)cmd[3]}" )

        ice_cmd=( "${(Qkv)ice_cmd[@]}" )
        main_cmd=( "${(Qkv)main_cmd[@]}" )

        # Comment
        [[ "$with_comments" = "1" && -n "$comment" ]] && buf+="${comment#$'\n'}"

        # ICE
        if [[ "${#ice_cmd}" -ge 1 ]]; then
            (( ice_cmd[disabled] || main_cmd[disabled] )) && buf+=": "
            buf+="zplugin ice"
            for tmp in "${(ok@)ice_cmd}"; do
                case "$tmp" in
                    (from|proto|report|depth|atload|atpull|atclone|if)
                        buf+=" $tmp${ice_cmd[$tmp]}"
                        ;;
                    (blockf)
                        buf+=" $tmp"
                        ;;
                esac
            done
            buf+=$'\n'
        fi

        # COMMAND
        if [[ "${#main_cmd}" -ge 1 ]]; then
            if [[ "${main_cmd[c]}" = (zplugin|zplg) ]]; then
                (( ice_cmd[disabled] || main_cmd[disabled] )) && buf+=": "
                if [[ "${main_cmd[sub]}" = (light|load|snippet|cdreplay|cdclear) ]]; then
                    buf+="zplugin ${main_cmd[sub]}"
                    [[ "${main_cmd[--command]}" = "1" ]] && buf+=" --command"
                    [[ "${main_cmd[-f]}" = "1" ]] && buf+=" -f"
                    [[ "${main_cmd[-q]}" = "1" ]] && buf+=" -q"
                    [[ -n "${main_cmd[url]}" ]] && buf+=" ${main_cmd[url]}"
                else
                    # Unknown subcommand
                    local -a keys
                    local key text="${main_cmd[c]}"
                    [[ -n "${main_cmd[unkn]}" ]] && text+=" ${main_cmd[unkn]}"
                    keys=( "${(kon)main_cmd[@]}" )
                    for key in "${keys[@]}"; do
                        [[ "$key" != arg_* ]] && continue
                        text+=" ${main_cmd[$key]}"
                    done

                    buf+="$text"
                fi
            else
                local -a keys
                local key text="${main_cmd[c]}"
                keys=( "${(kon)main_cmd[@]}" )
                for key in "${keys[@]}"; do
                    [[ "$key" != arg_* ]] && continue
                    text+=" ${main_cmd[$key]}"
                done
                buf+="$text"
            fi
            buf+=$'\n'
        fi
    done

    buf="${buf%$'\n'}"
    [[ "$whole" = "1" ]] && buf+="${(j::)ZCR_PB_ALL[post_block_begin,-1]}"

    reply=( "${(@f)buf}" )
}

# Called when [Save] pressed. Composes zshrc, performs the save,
# outputs status message.
-zcrasis_action_save() {
    -zcrasis_compose 1 1
    print -rl -- "${reply[@]}" >| "$zshrc_path"
    reply=()

    -zui_std_stalog "Saved to:" "\`$zshrc_path'"
}

# Updates main entry in given ($3) command packet.
#
# $1 - key to update in the main command
# $2 - data to store under the key
# $3 - index of command pack to alter
-zcrasis_update_main() {
    local key="$1" data="$2" idx="$3"
    local -a cmd
    local -A main_cmd

    cmd=( "${(@)cmdlist[(idx-1)*3+1,idx*3]}" )
    [[ -n "${cmd[3]}" ]] && main_cmd=( "${(z@)cmd[3]}" ) || return 1
    main_cmd=( "${(Qkv)main_cmd[@]}" )
    main_cmd[$key]="$data"

    cmdlist[idx*3]="${(j: :)${(qkv)main_cmd[@]}}"
    return 0
}

# Clears generators' working variables to
# trigger refresh from model-structures.
-zcrasis_clear_visual_state() {
    integer i size=$(( ${#cmdlist} / 3 ))
    for (( i=1; i<=size+15; i++ )); do
        unset "ZUI[toggle_dis_2_${i}]"
        unset "ZUI[toggle_command_2_${i}]"
        unset "ZUI[toggle_force_2_${i}]"
        unset "ZUI[toggle_mode_2_${i}]"

        unset "ZUI[my_tfield2_${i}_width]"
        unset "ZUI[my_tfield2_${i}_start]"
        unset "ZUI[my_tfield2_${i}_data]"
    done
}

# Adds snippet to $cmdlist and refreshes the view.
-zcrasis_action_add_snippet() {
    local url="${ZUI[my_tfield3_data]}"
    local -A main_cmd

    [[ -z "$url" || "$url" = \<*\> ]] && { -zui_std_stalog "" "" "" "WARNING: " "" "Aborted, please enter a proper snippet URL"; return; }
    [[ "$url" != /* && "$url" != (http|ftp|https):* ]] && -zui_std_stalog "" "" "" "WARNING: " "" "Snippet isn't absolute path or URL"

    main_cmd[c]="zplugin"
    main_cmd[sub]="snippet"
    main_cmd[url]="$url"

    -zcrasis_dbg_msg "Prepending snippet (data: ${(kv)main_cmd})"

    cmdlist[1,0]=( "" "" "${(j: :)${(qkv)main_cmd[@]}}" )
    -zui_std_set_mod_factor 2 $(( ${#cmdlist} / 3 ))
    -zcrasis_clear_visual_state

    -zcrasis_refresh2_all_string
    reply=( "$REPLY" "" )
}

# Adds plugin to $cmdlist and refreshes the view.
-zcrasis_action_add_plugin() {
    local url="${ZUI[my_tfield3_data]}"
    local -A main_cmd

    [[ -z "$url" || "$url" = \<*\> ]] && { -zui_std_stalog "" "" "" "WARNING: " "" "Aborted, please enter or select a proper plugin ID"; return; }
    [[ "$url" != [a-zA-Z0-9-]##/[a-zA-Z0-9-]## ]] && -zui_std_stalog "" "" "" "WARNING: " "" "Plugin ID isn't of the form \`user/plugin'"

    main_cmd[c]="zplugin"
    main_cmd[sub]="load"
    main_cmd[url]="$url"

    -zcrasis_dbg_msg "Prepending plugin (data: ${(kv)main_cmd})"

    cmdlist[1,0]=( "" "" "${(j: :)${(qkv)main_cmd[@]}}" )
    -zui_std_set_mod_factor 2 $(( ${#cmdlist} / 3 ))
    -zcrasis_clear_visual_state

    -zcrasis_refresh2_all_string
    reply=( "$REPLY" "" )
}

# ZUI generator that creates top menu (its hypertext).
# The menu can differ depending on current view mode
# (normal, preview, debug).
-zcrasis_generator_0() {
    local mod="$1" ice="$2"
    local pv_col dg_col dl_col ed_col co_col
    local -a optional

    reply=()

    -zui_util_map_bools '[[ ${ZUI[in_preview]} = 1 ]]' pv_col "${ZUI[BG_BLUE]}" "${ZUI[GREEN]}"
    -zui_util_map_bools '[[ ${ZUI[in_debug]} = 1 ]]' dg_col "${ZUI[BG_BLUE]}" "${ZUI[GREEN]}"
    -zui_util_map_bools '[[ "${ZUI[zc_delete_mode]}" = "1" ]]' dl_col "${ZUI[BG_BLUE]}" "${ZUI[RED]}"
    -zui_util_map_bools '[[ "${ZUI[zc_edit_mode]}" = "1" ]]' ed_col "${ZUI[BG_BLUE]}" "${ZUI[GREEN]}"
    -zui_util_map_bools '[[ "${ZUI[zc_compact_mode]}" = "1" ]]' co_col "${ZUI[BG_BLUE]}" "${ZUI[GREEN]}"

    # 1. - 4.
    -zui_std_rc_button "reload" "${ZUI[GREEN]}Reload${ZUI[FMT_END]}" -zcrasis_action_reload
    -zui_std_rc_button "save" "${ZUI[RED]}Save${ZUI[FMT_END]}" '-zcrasis_action_save; internal=1'
    -zui_std_rc_button "preview" "${pv_col}Preview${ZUI[FMT_END]}" -zcrasis_action_preview
    -zui_std_rc_button "debug" "${dg_col}Debug${ZUI[FMT_END]}" -zcrasis_action_debug_view

    (( ${ZUI[in_preview]} + ZUI[in_debug] == 0 )) && {
        # Variables of the text field
        (( ${+ZUI[my_tfield3_width]} == 0 )) && ZUI[my_tfield3_width]=34
        (( ${+ZUI[my_tfield3_start]} == 0 )) && ZUI[my_tfield3_start]=1
        (( ${+ZUI[my_tfield3_data]} == 0 )) && ZUI[my_tfield3_data]="<Enter or select plugin to add>"

        # 1.
        noglob -zui_std_text_field "tfield3_$mod" ZUI[my_tfield3_width] ZUI[my_tfield3_start] ZUI[my_tfield3_data] "" "" "" '' optional

        # Variables of the list box
        (( ${+ZUI[my_lbox1_width]} == 0 )) && ZUI[my_lbox1_width]=25
        (( ${+ZUI[my_lbox1_idx]} == 0 )) && ZUI[my_lbox1_idx]=1
        (( ${+ZUI[my_lbox1_opts]} == 0 )) && ZUI[my_lbox1_opts]="${(j:;:)chosen_plugins}"

        # 2.
        noglob -zui_std_list_box "lbox1_$mod" ZUI[my_lbox1_width] ZUI[my_lbox1_idx] ZUI[my_lbox1_opts] "" "" "" 'ZUI[my_tfield3_data]="${${(s:;:)ZUI[my_lbox1_opts]}[${ZUI[my_lbox1_idx]}]}"; [[ "${ZUI[my_lbox1_idx]}" = 1 ]] && ZUI[my_tfield3_data]="";' optional

        # 3. - 4.
        -zui_std_rc_button "snippet" "${ZUI[GREEN]}Add snippet${ZUI[FMT_END]}" -zcrasis_action_add_snippet optional
        -zui_std_rc_button "plugin" "${ZUI[GREEN]}Add plugin${ZUI[FMT_END]}" -zcrasis_action_add_plugin optional

        # 5. - 6.
        -zui_std_rc_button "delete_mode" "${dl_col}Delete Mode${ZUI[FMT_END]}" -zcrasis_action_delete_mode optional
        -zui_std_rc_button "edit_mode" "${ed_col}Edit Mode${ZUI[FMT_END]}" -zcrasis_action_edit_mode optional
        -zui_std_rc_button "compact_mode" "${co_col}Compact Mode${ZUI[FMT_END]}" -zcrasis_action_compact_mode optional

        local line1="${optional[5]} ${optional[6]} ${optional[7]}"
        local line2="${optional[1]} ${optional[3]} ${optional[4]}  Choose: ${optional[2]}"
    } || {
        local line1="" line2=""
    }

    reply=(
        "${reply[1]} ${reply[2]} ${reply[3]} ${reply[4]}"
        "$line1"
        ""
        "$line2"
    )

    [[ -z "$line1" && -z "$line2" ]] && reply[2,4]=()

    # Non-selectable lines   Hops to jump with [ and ]   Local anchors
    reply2=( )               reply3=( 1 )                reply4=( )
}

# ZUI generator that creates document block for each plugin,
# snippet or other command. This is module #2, each document
# block is an instance of this module.
-zcrasis_generator_A() {
    local mod="$1" ice="$2" comment
    local -a cmd output
    local -A ice_cmd main_cmd
    local var_name1 var_name2
    local num dis_col dis_col2 mode_col mode_text command_col force_col disabled_text

    cmd=( "${(@)cmdlist[(ice-1)*3+1,ice*3]}" )
    comment="${cmd[1]}"
    [[ -n "${cmd[2]}" ]] && ice_cmd=( "${(z@)cmd[2]}" )
    [[ -n "${cmd[3]}" ]] && main_cmd=( "${(z@)cmd[3]}" )

    ice_cmd=( "${(Qkv)ice_cmd[@]}" )
    main_cmd=( "${(Qkv)main_cmd[@]}" )

    output=()

    # Command number
    num="${(l:2::0:)ice}."

    # "Up", "Down"
    var_name1="my_mod${mod}_ice$(( ice-1 ))_size"
    var_name2="my_mod${mod}_ice$(( ice+1 ))_size"

    # 1.
    if [[ "$ice" -gt 1 ]]; then
        -zui_std_anchor "move_up_${mod}_${ice}" "1-1-${var_name1}" "" ",mod${mod}_ice${ice},mod${mod}_ice$(( ice - 1 ))," "" "${ZUI[YELLOW]}[Up]${ZUI[FMT_END]}" "-zcrasis_action_move_up $mod $ice" output
    else
        output+=( "[Up]" )
    fi

    # 2.
    if [[ "$ice" -lt $(( ${#cmdlist} / 3 )) ]]; then
        -zui_std_anchor "move_down_${mod}_${ice}" "1+1+${var_name2}" "" ",mod${mod}_ice${ice},mod${mod}_ice$(( ice + 1 ))," "" "${ZUI[YELLOW]}[Down]${ZUI[FMT_END]}" "-zcrasis_action_move_down $mod $ice" output
    else
        output+=( "[Down]" )
    fi

    # "DISABLED" or "Enabled"
    [[ -z "${ZUI[toggle_dis_${mod}_${ice}]}" ]] && ZUI[toggle_dis_${mod}_${ice}]="${main_cmd[disabled]:-0}" || -zcrasis_update_main disabled "${ZUI[toggle_dis_${mod}_${ice}]}" "$ice"
    -zui_util_map_bools "[[ \"${ZUI[toggle_dis_${mod}_${ice}]}\" = 1 ]]" "dis_col" "${ZUI[RED]}" "${ZUI[GREEN]}"
    -zui_util_map_bools "[[ \"${ZUI[toggle_dis_${mod}_${ice}]}\" = 1 ]]" "disabled_text" "DISABLED" "Enabled"
    -zui_util_map_bools "[[ \"${ZUI[toggle_dis_${mod}_${ice}]}\" = 1 && \"${ZUI[zc_compact_mode]}\" = 1 ]]" "dis_col2" "${ZUI[RED]}" "${ZUI[WHITE]}"

    # 3.
    -zui_std_rc_button "toggle_dis_${mod}_${ice}" "${dis_col}${disabled_text}${ZUI[FMT_END]}" '(( ZUI[toggle_dis_'"${mod}_${ice}"']=1-${ZUI[toggle_dis_'"${mod}_${ice}"']} )); -zui_std_fly_mod_regen '"$mod $ice"'; internal=1' output

    # 4. Delete
    -zui_std_button_ext "delete_${mod}_${ice}" "$mod" "$ice" "" "" "${ZUI[RED]}[X]${ZUI[FMT_END]}" -zcrasis_action_delete output
    if (( ZUI[zc_delete_mode] )); then
        output[4]+=" "
    else
        output[4]=""
    fi

    reply=()
    if [[ "${main_cmd[sub]}" = "snippet" ]]; then
        #
        # Url, edited in edit-mode
        #

        if [[ "${ZUI[zc_edit_mode]}" = 1 ]]; then
            # Variables of the text field
            (( ${+ZUI[my_tfield2_${ice}_width]} == 0 )) && ZUI[my_tfield2_${ice}_width]=$(( ${#main_cmd[url]} + 10 < 30 ? 30 : ${#main_cmd[url]} + 10 ))
            (( ${+ZUI[my_tfield2_${ice}_start]} == 0 )) && ZUI[my_tfield2_${ice}_start]=1
            (( ${+ZUI[my_tfield2_${ice}_data]} == 0 )) && ZUI[my_tfield2_${ice}_data]="${main_cmd[url]}"

            noglob -zui_std_text_field "tfield2_${mod}_${ice}" ZUI[my_tfield2_${ice}_width] ZUI[my_tfield2_${ice}_start] ZUI[my_tfield2_${ice}_data] "" "" "" '-zcrasis_update_main url "${ZUI[my_tfield2_'${ice}'_data]}" '$ice output
        else
            output+=( ${ZUI[MAGENTA]}${main_cmd[url]}${ZUI[FMT_END]} )
        fi

        #
        # command on/off
        #

        [[ -z "${ZUI[toggle_command_${mod}_${ice}]}" ]] && ZUI[toggle_command_${mod}_${ice}]="${main_cmd[--command]:-0}" || -zcrasis_update_main --command "${ZUI[toggle_command_${mod}_${ice}]}" $ice
        -zui_util_map_bools "[[ \"${ZUI[toggle_command_${mod}_${ice}]}\" = 1 ]]" "command_col" "${ZUI[BG_BLUE]}" "${ZUI[GREEN]}"
        local command_text="${command_col}as-command${ZUI[FMT_END]}"
        -zui_std_rc_button "toggle_command_${mod}_${ice}" "$command_text" '(( ZUI[toggle_command_'"${mod}_${ice}"']=1-${ZUI[toggle_command_'"${mod}_${ice}"']} )); -zui_std_fly_mod_regen '"$mod $ice"'; internal=1' output

        #
        # force on/off
        #

        [[ -z "${ZUI[toggle_force_${mod}_${ice}]}" ]] && ZUI[toggle_force_${mod}_${ice}]="${main_cmd[-f]:-0}" || -zcrasis_update_main -f "${ZUI[toggle_force_${mod}_${ice}]}" $ice
        -zui_util_map_bools "[[ \"${ZUI[toggle_force_${mod}_${ice}]}\" = 1 ]]" "force_col" "${ZUI[BG_BLUE]}" "${ZUI[GREEN]}"
        local force_text="${force_col}force${ZUI[FMT_END]}"
        -zui_std_rc_button "toggle_force_${mod}_${ice}" "$force_text" '(( ZUI[toggle_force_'"${mod}_${ice}"']=1-${ZUI[toggle_force_'"${mod}_${ice}"']} )); -zui_std_fly_mod_regen '"$mod $ice"'; internal=1' output

        #
        # Document
        #

        reply+=( "$num ${output[1]} ${output[2]} ${dis_col2}S${ZUI[FMT_END]} ${output[5]}" )
        reply+=( "${output[4]:-    }${output[3]} ${output[6]} ${output[7]}" )

        [[ "${ZUI[zc_compact_mode]}" = 1 ]] && reply[-1]=()
    elif [[ "${main_cmd[sub]}" = (light|load) ]]; then
        #
        # Url, edited in edit-mode
        #

        if [[ "${ZUI[zc_edit_mode]}" = 1 ]]; then
            # Variables of the text field
            (( ${+ZUI[my_tfield2_${ice}_width]} == 0 )) && ZUI[my_tfield2_${ice}_width]=30
            (( ${+ZUI[my_tfield2_${ice}_start]} == 0 )) && ZUI[my_tfield2_${ice}_start]=1
            (( ${+ZUI[my_tfield2_${ice}_data]} == 0 )) && ZUI[my_tfield2_${ice}_data]="${main_cmd[url]}"

            noglob -zui_std_text_field "tfield2_${mod}_${ice}" ZUI[my_tfield2_${ice}_width] ZUI[my_tfield2_${ice}_start] ZUI[my_tfield2_${ice}_data] "" "" "" '-zcrasis_update_main url "${ZUI[my_tfield2_'${ice}'_data]}" '$ice output
        else
            output+=( "${ZUI[CYAN]}${main_cmd[url]}${ZUI[FMT_END]}" )
        fi

        #
        # Mode: light or normal ("load")
        #

        [[ -z "${ZUI[toggle_mode_${mod}_${ice}]}" ]] && ZUI[toggle_mode_${mod}_${ice}]="${main_cmd[sub]}" || -zcrasis_update_main sub "${ZUI[toggle_mode_${mod}_${ice}]}" $ice
        -zui_util_map_bools "[[ \"${ZUI[toggle_mode_${mod}_${ice}]}\" = light ]]" "mode_col" "${ZUI[YELLOW]}" "${ZUI[GREEN]}"
        -zui_util_map_bools "[[ \"${ZUI[toggle_mode_${mod}_${ice}]}\" = light ]]" "mode_text" light normal
        -zui_std_rc_button "toggle_mode_${mod}_${ice}" "Mode: ${mode_col}${mode_text}${ZUI[FMT_END]}" '[[ ${ZUI[toggle_mode_'"${mod}_${ice}"']} = light ]] && ZUI[toggle_mode_'"${mod}_${ice}"']=load || ZUI[toggle_mode_'"${mod}_${ice}"']=light; -zui_std_fly_mod_regen '"$mod $ice"'; internal=1' output

        #
        # Compile
        #

        -zui_std_rc_button "compile_${mod}_${ice}" "${ZUI[YELLOW]}Compile${ZUI[FMT_END]}" 'zplugin compile '${main_cmd[url]}'; print Done.; builtin read tmp;' output

        #
        # Document
        #

        reply+=( "$num ${output[1]} ${output[2]} ${dis_col2}P${ZUI[FMT_END]} ${output[5]}" )
        reply+=( "${output[4]:-    }${output[3]} ${output[6]} ${output[7]}" )

        [[ "${ZUI[zc_compact_mode]}" = 1 ]] && reply[-1]=()
    elif [[ "${main_cmd[sub]}" = "cdreplay" ]]; then
        reply+=( "$num ${output[1]} ${output[2]} cdreplay" )
        reply+=( "${output[4]:-    }${output[3]}" )

        [[ "${ZUI[zc_compact_mode]}" = 1 ]] && reply[-1]=()
    elif [[ "${main_cmd[sub]}" = "cdclear" ]]; then
        reply+=( "$num ${output[1]} ${output[2]} cdclear" )
        reply+=( "${output[4]:-    }${output[3]}" )

        [[ "${ZUI[zc_compact_mode]}" = 1 ]] && reply[-1]=()
    else
        # Custom command
        local -a keys
        local key text="${main_cmd[c]}"
        [[ -n "${main_cmd[unkn]}" ]] && text+=" ${main_cmd[unkn]}"
        keys=( "${(kon)main_cmd[@]}" )
        for key in "${keys[@]}"; do
            [[ "$key" != arg_* ]] && continue
            text+=" ${main_cmd[$key]}"
        done
        [[ -n "${main_cmd[unkn]}" ]] && text+=" (${ZUI[RED]}unknown Zplugin subcommand${ZUI[FMT_END]})"
        reply+=( "$num ${output[1]} ${output[2]} $text" )
        reply+=( "${output[4]:-    }${output[3]}" )

        [[ "${ZUI[zc_compact_mode]}" = 1 ]] && reply[-1]=()
    fi

    # Instead of debugging ZUI, I've added '-1' here
    var_name1="my_mod${mod}_ice${ice}_size"
    : "${(P)var_name1::=${#reply}-1}"

    # Non-selectable lines   Hops to jump with [ and ]   Local anchors
    reply2=( )               reply3=( 1 )                reply4=( move_up_${mod}_${ice} move_down_${mod}_${ice} )
}

# ZUI generator that creates preview text. This is module 3.
# There is 0 or 1 instance of this module, depending on chosen
# view.
-zcrasis_generator_B() {
    -zcrasis_compose

    # Non-selectable lines   Hops to jump with [ and ]   Local anchors
    reply2=( )               reply3=( 1 )                reply4=( )
}

# ZUI generator that creates debug-report text. This is module 4.
# There is 0 or 1 instance of this module, depending on chosen
# view.
-zcrasis_generator_DBG() {
    reply=()

    # Variables of the text field
    (( ${+ZUI[my_tfield1_width]} == 0 )) && ZUI[my_tfield1_width]=50
    (( ${+ZUI[my_tfield1_start]} == 0 )) && ZUI[my_tfield1_start]=1
    (( ${+ZUI[my_tfield1_data]} == 0 )) && ZUI[my_tfield1_data]="$HOME/crasis-report.txt"

    noglob -zui_std_text_field "report_path" ZUI[my_tfield1_width] ZUI[my_tfield1_start] ZUI[my_tfield1_data] "" "" "" ''
    -zui_std_rc_button "save_report" "${ZUI[YELLOW]}Save${ZUI[FMT_END]}" 'print -rl -- "${ZCR_DEBUG_MSGS[@]}" >| "${ZUI[my_tfield1_data]}"; -zui_std_stalog "Report written to: " "\`${ZUI[my_tfield1_data]}'"'"'"; internal=1;'

    reply=( "Send reports to: ${ZUI[YELLOW]}psprint${ZUI[FMT_END]}${ZUI[BOLD]}${ZUI[YELLOW]}@${ZUI[FMT_END]}${ZUI[YELLOW]}zdharma.org${ZUI[FMT_END]}. Please include Zshrc if possible."
        ""
        "${reply[1]} ${reply[2]}"
        ""
        "${ZCR_DEBUG_MSGS[@]}"
    )

    # Non-selectable lines   Hops to jump with [ and ]   Local anchors
    reply2=( )               reply3=( 1 )                reply4=( )
}

# Ran at startup and after [Reload] button press.
# Performs full zshrc processing, recognizes normal
# and zplugin-related zshrc parts.
-zcrasis_action_reload() {
    local id="$1" msg
    float -F 2 sum=0.0
    local -a stats

    -zcrasis_dbg_msg "Loading \`$zshrc_path'..."
    zshrc="$(<$zshrc_path)"
    -zcrasis_dbg_msg "Read <ZSHRCSIZE> bytes (<ZSHRCLINES> lines)"
    -zcrasis_dbg_msg ""

    -zcrasis_clear_visual_state

    print "Parsing zshrc..."
    cmdlist=()
    coidx=1
    stats=()

    [[ -n "$id" ]] && { -zcrasis_dbg_msg "[Reload] pressed"; -zcrasis_dbg_msg ""; }

    [[ "${ZUI[in_preview]}" = 1 ]] && ZUI[in_preview]=0
    [[ "${ZUI[in_debug]}" = 1 ]] && ZUI[in_debug]=0

    typeset -F 2 SECONDS=0
    -zcrasis-tokenize-zsh-rc
    stats+=( "Tokenization time: $SECONDS seconds" )
    sum+=SECONDS

    SECONDS=0
    -zcrasis-process-zsh-rc
    stats+=( "Main processing time: $SECONDS seconds" )
    sum+=SECONDS

    SECONDS=0
    -zcrasis-process-zplugin-commands
    stats+=( "Zplugin-commands processing time: $SECONDS seconds" )
    sum+=SECONDS

    for msg in "${stats[@]}"; do
        -zcrasis_dbg_msg "$msg"
    done

    -zcrasis_dbg_msg "Total time: $sum seconds"
    -zcrasis_dbg_msg ""

    -zui_std_stalog "Read " "\`$zshrc_path' " "(time: $sum sec)"

    # Called from button?
    [[ -n "$id" ]] && {
        integer size=$(( ${#cmdlist} / 3 ))

        -zui_std_set_mod_factor 2 "$size"
        -zui_std_set_mod_factor 3 0
        -zui_std_set_mod_factor 4 0

        -zcrasis_refresh2_all_string

        reply=( "$REPLY" "" )
    } || reply=()
}

-zcrasis_action_reload

# Create needed local parameters
integer i
for (( i=1; i<=${#cmdlist}/3+15; i++ )); do
    local my_mod2_ice${i}_size="0"
done

# Don't reset current segment on jump
ZUI[reset_current_segment]="no"

## Start application ##
zui-event-loop 1:-zcrasis_generator_0 $(( ${#cmdlist} / 3 )):-zcrasis_generator_A \
               0:-zcrasis_generator_B 0:-zcrasis_generator_DBG

-zui_std_cleanup serialize

return 0

# vim:ft=zsh

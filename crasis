# -*- mode: shell-script -*-
# Started from Zle or from command line
#
# Copyright (c) 2017 Sebastian Gniazdowski

-zui_std_cleanup deserialize:"zplugin-crasis"
-zui_std_init app:"zplugin-crasis" app_name:"Zplugin-Crasis"
emulate -LR zsh -o extendedglob -o typesetsilent -o warncreateglobal
-zui_std_init2

-zui_std_store_default_app_config b:border 1
-zui_std_store_default_app_config b:top_anchors 0  # no top-anchors

#
# CONSTANTS
#

local -A TOKEN_TYPES

TOKEN_TYPES=(

  # Precommand

  'builtin'     1
  'command'     1
  'exec'        1
  'nocorrect'   1
  'noglob'      1
  'pkexec'      1

  # Control flow
  # Tokens that at "command position" are followed by a command

  $'\x7b'   2 # {
  $'\x28'   2 # (
  '()'      2
  'while'   2
  'until'   2
  'if'      2
  'then'    2
  'elif'    2
  'else'    2
  'do'      2
  'time'    2
  'coproc'  2
  '!'       2

  # Command separators

  '|'   3
  '||'  3
  ';'   3
  '&'   3
  '&&'  3
  '|&'  3
  '&!'  3
  '&|'  3
)
#
# PARAMETERS
#

# Document to process
local zshrc_path="${ZDOTDIR:-$HOME}/.zshrc" zshrc

# The bits returned by -zplg-process-buffer
local token prev_token spaces prev_spaces next_token next_spaces

# Command detection
integer at_command=1 in_zplugin=0

# Functions
local fun_name
integer next_fun=0 cur_fun=0 prev_fun=0

# Depths in functions, i.e. -1 not in function, 0 in one function, etc.
integer depth=0 prev_depth=0 fun_depth=-1 anon_depth=-1 descentff=0 descentfa=0

# Nested functions tracking
integer nested_fun=0 next_nested_fun=0 prev_nested_fun=0
local -a fun_stack_depths

# Text data
integer was_zplugin=0 pre_block_end=0 post_block_begin=0

# Common
local -a mbegin mend match
local MATCH; integer MBEGIN MEND

#
# Load zshrc
#

[[ ! -e "$zshrc_path" ]] && { print "No such file \`$zshrc_path'${ZDOTDIR:+ (using \$ZDOTDIR)}"; return 1; }
[[ ! -f "$zshrc_path" ]] && { print "\`$zshrc_path' isn't a plain, regular file${ZDOTDIR:+ (using \$ZDOTDIR)}"; return 1; }
[[ ! -r "$zshrc_path" ]] && { print "No read permissions to \`$zshrc_path'${ZDOTDIR:+ (using \$ZDOTDIR)}"; return 1; }
[[ ! -w "$zshrc_path" ]] && { print "No write permissions to \`$zshrc_path'${ZDOTDIR:+ (using \$ZDOTDIR)}"; return 1; }
[[ ! -s "$zshrc_path" ]] && { print "File \`$zshrc_path' is empty, aborting"; return 1; }

local zshrc="$(<$zshrc_path)"

# Runs -zcrasis-process-buffer() on $zshrc (containing
# the loaded zshrc)
-zcrasis-tokenize-zsh-rc() {
    -zcrasis-process-buffer "$zshrc" 1
}

# Parses tokens of the loaded zshrc and detects:
# - functions
# - block preceding zplugin commands
# - block with those commands
# - block following them
-zcrasis-process-zsh-rc() {
    integer i j size="${#ZCR_PB_WORDS}"

    for (( i=1; i<=size; ++ i )); do
        token="${ZCR_PB_WORDS[i]}"
        spaces="${ZCR_PB_SPACES[i]}"
        next_token="${ZCR_PB_WORDS[i+1]}"
        next_spaces="${ZCR_PB_SPACES[i+1]}"

        cur_fun=0 prev_fun=0 descentff=0 descentfa=0
        nested_fun=0 prev_nested_fun=0

        (( next_fun )) && { next_fun=0 cur_fun=1 prev_fun=0 anon_depth=-1; }
        (( next_nested_fun )) && { next_nested_fun=0 nested_fun=1 prev_nested_fun=0; }

        # Explicit future-function
        if [[ "$token" = "function" && ( "$fun_depth" -lt 0 ) && ( $anon_depth -lt 0 ) ]]; then
            next_fun=1 cur_fun=0 prev_fun=0 anon_depth=-1
        # Detect top-level prev-function differentiating from anonymous function
        elif [[ "$token" = "()" && ( "$fun_depth" -lt 0 ) && ( $anon_depth -lt 0 ) ]]; then
            if [[ "$spaces" = *$'\n'* || -z "$prev_token" || "${TOKEN_TYPES[$prev_token]}" = [123] ]]; then
                next_fun=0 cur_fun=0 prev_fun=0 anon_depth=$depth
            else
                next_fun=0 cur_fun=0 prev_fun=1 anon_depth=-1
            fi
        # Must be a nested future-function
        elif [[ "$token" = "function" ]]; then
            next_nested_fun=1 nested_fun=0 prev_nested_fun=0
        # Is it a nested prev-function?
        elif [[ "$token" = "()" && "$nested_fun" -eq 0 && "$depth" -gt "$fun_stack_depths[-1]" ]]; then
            if [[ "$spaces" != *$'\n'* && -n "$prev_token" && "${TOKEN_TYPES[$prev_token]}" != [123] ]]; then
                next_nested_fun=0 nested_fun=0 prev_nested_fun=1
            fi
        elif [[ "$token" = "{" ]]; then
            (( ++ depth ))
        elif [[ "$token" = "}" ]]; then
            (( -- depth ))
        fi

        # Check if any final function-flag is raised
        if (( cur_fun )); then
            fun_name="$token"
            fun_depth="$depth"
            fun_stack_depths+=( "$depth" )
        elif (( prev_fun )); then
            fun_name="$prev_token"
            fun_depth="$depth"
            fun_stack_depths+=( "$depth" )
        fi

        # Track nested functions
        if (( nested_fun + prev_nested_fun )); then
            fun_stack_depths+=( "$depth" )
        fi

        # Ascent to function - skip '{'
        if (( fun_depth >= 0 && depth == (fun_depth + 1) )) && [[ "$token" = "{" ]]; then
            :
        # In function
        elif (( fun_depth >= 0 && depth > fun_depth )); then
            if [[ "$token" != [[:blank:]]#\#* ]]; then
                : # do something with a non-comment function token
            fi
            # Handle descent from nested function
            if (( ${#fun_stack_depths} > 0 && depth == fun_stack_depths[-1] && prev_depth == fun_stack_depths[-1] + 1 )); then
                fun_stack_depths[-1]=()
            fi
        # In anonymous-function
        elif (( anon_depth >= 0 && depth > anon_depth )); then
            if (( ${#fun_stack_depths} > 0 && depth == fun_stack_depths[-1] && prev_depth == fun_stack_depths[-1] + 1 )); then
                fun_stack_depths[-1]=()
            fi
        # Descent from function - skip '}'
        elif (( fun_depth >= 0 && depth == fun_depth && prev_depth == fun_depth + 1 )); then
            descentff=1
        # Descent from anon
        elif (( anon_depth >= 0 && depth == anon_depth && prev_depth == anon_depth + 1 )); then
            descentfa=1
        fi

        # Anon function in top-level
        if (( anon_depth >= 0 && fun_depth < 0 )); then
            [[ "$token" != [[:blank:]]#\#* ]] && : # do something with non-comment anon-function token
        fi

        # Check for introduction of Zplugin call
        if [[ "$spaces" = *$'\n'* || -z "$prev_token" || "${TOKEN_TYPES[$prev_token]}" = [123] ]]; then
            at_command=1
            (( in_zplugin )) && post_block_begin=2*i-1
            [[ "$token" != [[:blank:]]#\#* ]] && in_zplugin=0 || { (( in_zplugin )) && in_zplugin=1; }
        fi

        # Command token
        if (( at_command )); then
            at_command=0
            # Zplugin call not in function
            if [[ "$cur_fun" -eq 0 && "$next_token" != "()" && "$fun_stack_depths[-1]" -le "0" ]]; then
                if [[ "$token" = (zplugin|zplg) || ( "$token" = ":" && "$next_token" = (zplugin|zplg) ) ]]; then
                    in_zplugin=1
                    (( was_zplugin == 0 )) && {
                        for (( j=i-1; j >= 1; j -- )); do
                            [[ "${ZCR_PB_WORDS[j]}" != [[:blank:]]#\#* || "${ZCR_PB_SPACES[j+1]}" = *$'\n'*$'\n'* ]] && { pre_block_end=2*j; break; }
                        done
                    }
                    was_zplugin=1

                    # Revive at_command mode if disabled zplugin command
                    [[ "$token" = ":" ]] && at_command=1
                fi
            fi
        fi

        if (( in_zplugin )); then
            : # do something with Zplugin-related lines
        fi

        # Late disable of anonymous function
        if (( descentfa )); then
            anon_depth=-1
        # Late disable of normal function
        elif (( descentff )); then
            fun_name=""
            fun_depth=-1
            fun_stack_depths[-1]=()
        # No-function text gathering
        elif (( next_fun == 0 && cur_fun == 0 && prev_fun == 0 && anon_depth < 0 && fun_depth < 0 )); then
            if [[ "$next_token" != "()" || "$next_spaces" = *$'\n'* || "${TOKEN_TYPES[$token]}" = 3 ]]; then
                [[ "$token" != [[:blank:]]#\#* ]] && : # do something with script-body token
            fi
        fi

        # History of state
        prev_depth="$depth"
        prev_token="$token"
        prev_spaces="$spaces"
    done

    (( pre_block_end == 0 )) && pre_block_end=2*(i-1)
    (( post_block_begin == 0 )) && post_block_begin=2*i-1 || {
        # Detect not related trailing comments
        for (( j=(post_block_begin+1)/2-1; j >= 1; j -- )); do
            [[ "${ZCR_PB_WORDS[j]}" = [[:blank:]]#\#* && "${ZCR_PB_WORDS[j]}" != [[:blank:]]#\#[[:blank:]]#zplugin* ]] && {
                post_block_begin=2*j-1
            } || break
        done
    }
}

# Processes block with zplugin commands established in
# -zcrasis-process-zsh-rc() and generates $commands
# array which holds serialized hashes of every zplugin
# invocation, mixed-in additional commands, comments.
-zcrasis-process-zplugin-commands() {
    # From start to end of zplugin block
    for (( i=(pre_block_end/2)+1; i<=(post_block_begin+1)/2-1; ++ i )); do
        token="${ZCR_PB_WORDS[i]}"
        spaces="${ZCR_PB_SPACES[i]}"
        next_token="${ZCR_PB_WORDS[i+1]}"
        next_spaces="${ZCR_PB_SPACES[i+1]}"

        # New command?
        if [[ "$spaces" = *$'\n'* || -z "$prev_token" || "${TOKEN_TYPES[$prev_token]}" = [123] ]]; then
            in_zplugin=1

            if [[ "${cmd3[c]}" = "zplugin" && "${cmd3[sub]}" = "ice" ]]; then
                commands[coidx+1]="${(j: :)${(qkv)cmd3[@]}}"
            elif [[ "${cmd3[c]}" = "zplugin" && "${cmd3[sub]}" != "ice" ]]; then
                commands[coidx+2]="${(j: :)${(qkv)cmd3[@]}}"
                coidx+=3
            fi

            cmd3=()
        fi

        # Command token
        if [[ "$token" = [[:blank:]]#\#* ]]; then
            if (( in_zplugin == 1 )); then
                commands[coidx]+="$token"$'\n'
            else
                cmd3[comment]="$token"
            fi
        elif (( in_zplugin == 1 )); then
            [[ "$token" = (zplugin|zplg) ]] && cmd3[c]="zplugin" || cmd3[c]="$token"
            # Postpone current state to next token
            [[ "$token" = ":" ]] && { cmd3[disabled]=1; (( in_zplugin -- )); }
        elif (( in_zplugin == 2 )); then
            if [[ "${cmd3[c]}" = "zplugin" ]]; then
                [[ "$token" = (ice|load|light|snippet|cdclear|cdreplay) ]] && cmd3[sub]="$token" || { cmd3[sub]="unkn"; cmd3[unkn]="$token"; }
            else
                cmd3[arg_1]="$token"
            fi
        else
            if [[ "${cmd3[sub]}" = "ice" ]]; then
                [[ "$token" = (#b)(from|proto|report|depth|blockf|atload|atpull|atclone|if)(*) ]] && cmd3[${match[1]}]="${match[2]}"
            elif [[ "${cmd3[sub]}" = (load|light) ]]; then
                cmd3[url]="$token"
            elif [[ "${cmd3[sub]}" = "snippet" ]]; then
                [[ "$token" = "-f" ]] && cmd3[-f]="1" || {
                    [[ "$token" = "--command" ]] && cmd3[--command]="1" || {
                        cmd3[url]="$token"
                    }
                }
            elif [[ "${cmd3[sub]}" = "cdclear" ]]; then
                [[ "$token" = "-q" ]] && cmd3[-q]="1"
            elif [[ "${cmd3[sub]}" = "cdreplay" ]]; then
                :
            elif [[ "${cmd3[sub]}" = "unkn" ]]; then
                # Argument following "zplugin <unknown> ..."
                cmd3[arg_$(( in_zplugin - 2 ))]="$token"
            else
                # Argument following "<unknown> <arg_1> ..."
                cmd3[arg_$(( in_zplugin - 1 ))]="$token"
            fi
        fi

        # Advance deeper into "zplugin ..." if it wasn't comment
        #[[ "$token" != [[:blank:]]#\#* ]] && in_zplugin+=1
        in_zplugin+=1
    done

    if [[ -n "${cmd3[c]}" ]];then
        if [[ "${cmd3[c]}" = "zplugin" && "${cmd3[sub]}" = "ice" ]]; then
            commands[coidx+1]="${(j: :)${(qkv)cmd3[@]}}"
        elif [[ "${cmd3[c]}" = "zplugin" && "${cmd3[sub]}" != "ice" ]]; then
            commands[coidx+2]="${(j: :)${(qkv)cmd3[@]}}"
        fi
    fi
}

# Generator for module 1
-zcrasis_generator_A() {
    local mod="$1" ice="$2"

    # Content
    reply=( "Hello World from ${ZUI[YELLOW]}ZUI${ZUI[FMT_END]}! Module $mod, instance $ice." )

    # Non-selectable lines   Hops to jump with [ and ]   Local anchors
    reply2=( )               reply3=( 1 )                reply4=( )
}

-zcrasis-tokenize-zsh-rc
-zcrasis-process-zsh-rc
-zcrasis-process-zplugin-commands

## Start application ##
zui-event-loop 1:-zcrasis_generator_A

-zui_std_cleanup serialize

return 0

# vim:ft=zsh
